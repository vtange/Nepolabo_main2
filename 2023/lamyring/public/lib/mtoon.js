(()=>{"use strict";var e={d:(i,n)=>{for(var t in n)e.o(n,t)&&!e.o(i,t)&&Object.defineProperty(i,t,{enumerable:!0,get:n[t]})},o:(e,i)=>Object.prototype.hasOwnProperty.call(e,i)},i={};function n(e,i,n,t){var o,a=arguments.length,r=a<3?i:null===t?t=Object.getOwnPropertyDescriptor(i,n):t;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)r=Reflect.decorate(e,i,n,t);else for(var s=e.length-1;s>=0;s--)(o=e[s])&&(r=(a<3?o(r):a>3?o(i,n,r):o(i,n))||r);return a>3&&r&&Object.defineProperty(i,n,r),r}e.d(i,{MToonMaterial:()=>f}),Object.create,Object.create;const t=window.BABYLON;class o{constructor(e,i){this.scene=e,this.material=i,this.name=`MToonOutline_${i.name}_${o.rendererId++}`,this.scene._addComponent(this),this._engine=this.scene.getEngine(),this._passIdForDrawWrapper=[];for(let e=0;e<1;++e)this._passIdForDrawWrapper[e]=this._engine.createRenderPassId(`Outline Renderer (${e})`)}register(){this.scene._afterRenderingMeshStage.registerStep(t.SceneComponentConstants.STEP_AFTERRENDERINGMESH_OUTLINE,this,this._afterRenderingMesh)}rebuild(){}dispose(){for(let e=0;e<this._passIdForDrawWrapper.length;++e)this._engine.releaseRenderPassId(this._passIdForDrawWrapper[e])}render(e,i,n){n=null!=n?n:this._passIdForDrawWrapper[0];const t=this.scene,o=e.effect;if(!o||!o.isReady()||!this.scene.activeCamera)return;const a=e._getDrawWrapper(n,!0);if(!a)return;if(a.setEffect(o),!a.effect||!a.effect.isReady())return;const r=e.getMesh(),s=r._internalAbstractMeshDataInfo._actAsRegularMesh?r:null,l=e.getRenderingMesh(),d=s||l;t.activeCamera&&(this.material.applyOutlineCullMode(),this.material.enableOutlineRender(),this._engine.enableEffect(a),this.isHardwareInstancedRendering(e,i)||l._bind(e,o,this.material.fillMode),this.material._preBind(o),l._processRendering(d,e,o,this.material.fillMode,i,this.isHardwareInstancedRendering(e,i),((i,n,t)=>{t&&t.bindForSubMesh(n,d,e)}),this.material),this.material.restoreOutlineCullMode(),this.material.disaableOutlineRender())}_afterRenderingMesh(e,i,n){if(!this.willRender(i))return;const t=this._engine.cullBackFaces;this._engine.cullBackFaces=!1,this.render(i,n,this._passIdForDrawWrapper[0]),this._engine.cullBackFaces=t}isHardwareInstancedRendering(e,i){return!!this._engine.getCaps().instancedArrays&&null!==i.visibleInstances[e._id]&&void 0!==i.visibleInstances[e._id]&&e.getRenderingMesh().hasThinInstances}willRender(e){const i=e.getMaterial();return!(!i||"MToonMaterial"!==i.getClassName()||i.getOutlineRendererName()!==this.name)}}o.rendererId=0;class a extends t.MaterialDefines{constructor(e){super(e),this.CUSTOMUSERLIGHTING=!0,this.MTOON_OUTLINE_WIDTH_WORLD=!1,this.MTOON_OUTLINE_WIDTH_SCREEN=!1,this.MTOON_OUTLINE_COLOR_FIXED=!1,this.MTOON_OUTLINE_COLOR_MIXED=!1,this.MTOON_DEBUG_NORMAL=!1,this.MTOON_DEBUG_LITSHADERRATE=!1,this.SHADE=!1,this.SHADEDIRECTUV=0,this.RECEIVE_SHADOW=!1,this.RECEIVE_SHADOWDIRECTUV=0,this.SHADING_GRADE=!1,this.SHADING_GRADEDIRECTUV=0,this.RIM=!1,this.RIMDIRECTUV=0,this.MATCAP=!1,this.MATCAPDIRECTUV=0,this.OUTLINE_WIDTH=!1,this.OUTLINE_WIDTHDIRECTUV=0,this.UV_ANIMATION_MASK=!1,this.UV_ANIMATION_MASKDIRECTUV=0,this.MAINUV1=!1,this.MAINUV2=!1,this.MAINUV3=!1,this.MAINUV4=!1,this.MAINUV5=!1,this.MAINUV6=!1,this.DIFFUSE=!1,this.DIFFUSEDIRECTUV=0,this.BAKED_VERTEX_ANIMATION_TEXTURE=!1,this.EMISSIVE=!1,this.EMISSIVEDIRECTUV=0,this.BUMP=!1,this.BUMPDIRECTUV=0,this.PARALLAX=!1,this.PARALLAXOCCLUSION=!1,this.CLIPPLANE=!1,this.CLIPPLANE2=!1,this.CLIPPLANE3=!1,this.CLIPPLANE4=!1,this.CLIPPLANE5=!1,this.CLIPPLANE6=!1,this.ALPHATEST=!1,this.DEPTHPREPASS=!1,this.ALPHAFROMDIFFUSE=!1,this.POINTSIZE=!1,this.FOG=!1,this.NORMAL=!1,this.UV1=!1,this.UV2=!1,this.UV3=!1,this.UV4=!1,this.UV5=!1,this.UV6=!1,this.VERTEXCOLOR=!1,this.VERTEXALPHA=!1,this.NUM_BONE_INFLUENCERS=0,this.BonesPerMesh=0,this.BONETEXTURE=!1,this.BONES_VELOCITY_ENABLED=!1,this.INSTANCES=!1,this.THIN_INSTANCES=!1,this.OBJECTSPACE_NORMALMAP=!1,this.LOGARITHMICDEPTH=!1,this.TWOSIDEDLIGHTING=!1,this.SHADOWFLOAT=!1,this.MORPHTARGETS=!1,this.MORPHTARGETS_NORMAL=!1,this.MORPHTARGETS_TANGENT=!1,this.MORPHTARGETS_UV=!1,this.NUM_MORPH_INFLUENCERS=0,this.MORPHTARGETS_TEXTURE=!1,this.NONUNIFORMSCALING=!1,this.PREMULTIPLYALPHA=!1,this.ALPHATEST_AFTERALLALPHACOMPUTATIONS=!1,this.ALPHABLEND=!0,this.PREPASS=!1,this.PREPASS_IRRADIANCE=!1,this.PREPASS_IRRADIANCE_INDEX=-1,this.PREPASS_ALBEDO_SQRT=!1,this.PREPASS_ALBEDO_SQRT_INDEX=-1,this.PREPASS_DEPTH=!1,this.PREPASS_DEPTH_INDEX=-1,this.PREPASS_NORMAL=!1,this.PREPASS_NORMAL_INDEX=-1,this.PREPASS_POSITION=!1,this.PREPASS_POSITION_INDEX=-1,this.PREPASS_VELOCITY=!1,this.PREPASS_VELOCITY_INDEX=-1,this.PREPASS_REFLECTIVITY=!1,this.PREPASS_REFLECTIVITY_INDEX=-1,this.SCENE_MRT_COUNT=0,this.IMAGEPROCESSING=!1,this.VIGNETTE=!1,this.VIGNETTEBLENDMODEMULTIPLY=!1,this.VIGNETTEBLENDMODEOPAQUE=!1,this.TONEMAPPING=!1,this.TONEMAPPING_ACES=!1,this.CONTRAST=!1,this.COLORCURVES=!1,this.COLORGRADING=!1,this.COLORGRADING3D=!1,this.SAMPLER3DGREENDEPTH=!1,this.SAMPLER3DBGRMAP=!1,this.IMAGEPROCESSINGPOSTPROCESS=!1,this.SKIPFINALCOLORCLAMP=!1,this.MULTIVIEW=!1,this.ORDER_INDEPENDENT_TRANSPARENCY=!1,this.ORDER_INDEPENDENT_TRANSPARENCY_16BITS=!1,this.IS_REFLECTION_LINEAR=!1,this.IS_REFRACTION_LINEAR=!1,this.EXPOSURE=!1,this.rebuild()}setReflectionMode(e){throw new Error("This material cannot use `setReflectionMode`")}}const r={effect:null,subMesh:null};var s,l,d,h;!function(e){e[e.None=0]="None",e[e.Normal=1]="Normal",e[e.LitShadeRate=2]="LitShadeRate"}(s||(s={})),function(e){e[e.FixedColor=0]="FixedColor",e[e.MixedLighting=1]="MixedLighting"}(l||(l={})),function(e){e[e.None=0]="None",e[e.WorldCorrdinates=1]="WorldCorrdinates",e[e.ScreenCoordinates=2]="ScreenCoordinates"}(d||(d={})),function(e){e[e.Off=0]="Off",e[e.Front=1]="Front",e[e.Back=2]="Back"}(h||(h={}));class f extends t.PushMaterial{constructor(e,i){super(e,i),this._diffuseTexture=null,this.diffuseTexture=null,this._emissiveTexture=null,this.emissiveTexture=null,this._bumpTexture=null,this.bumpTexture=null,this._shadeTexture=null,this.shadeTexture=null,this._receiveShadowTexture=null,this.receiveShadowTexture=null,this._shadingGradeTexture=null,this.shadingGradeTexture=null,this._rimTexture=null,this.rimTexture=null,this._matCapTexture=null,this.matCapTexture=null,this._outlineWidthTexture=null,this.outlineWidthTexture=null,this._uvAnimationMaskTexture=null,this.uvAnimationMaskTexture=null,this.diffuseColor=new t.Color3(1,1,1),this.ambientColor=new t.Color3(0,0,0),this.emissiveColor=new t.Color3(0,0,0),this.shadeColor=new t.Color3(.97,.81,.86),this.rimColor=new t.Color3(0,0,0),this.outlineColor=new t.Color3(0,0,0),this.useEmissiveAsIllumination=!1,this.linkEmissiveWithDiffuse=!1,this.useReflectionOverAlpha=!1,this._disableLighting=!1,this.useObjectSpaceNormalMap=!1,this.useParallax=!1,this.useParallaxOcclusion=!1,this.specularSupported=!1,this.useLightmapAsShadowmap=!1,this.useVertexColor=!1,this.useBones=!0,this.useMorphTargets=!0,this.useVertexAlpha=!1,this.useBakedVertexAnimation=!1,this.alphaCutOff=.4,this._useAlphaFromDiffuseTexture=!0,this._maxSimultaneousLights=4,this._invertNormalMapX=!0,this._invertNormalMapY=!0,this._twoSidedLighting=!1,this._renderTargets=new t.SmartArray(16),this._worldViewProjectionMatrix=t.Matrix.Zero(),this._globalAmbientColor=new t.Color3(0,0,0),this._cacheHasRenderTargetTextures=!1,this._bumpScale=1,this._receiveShadowRate=1,this._shadingGradeRate=1,this._shadeShift=0,this._shadeToony=.9,this._lightColorAttenuation=0,this._indirectLightIntensity=.1,this._rimLightingMix=0,this._rimFresnelPower=1,this._rimLift=0,this._outlineWidth=.5,this._outlineScaledMaxDistance=1,this._outlineLightingMix=1,this._uvAnimationScrollX=0,this._uvAnimationScrollY=0,this._uvAnimationRotation=0,this._alphaTest=!1,this._alphaBlend=!1,this._debugMode=s.None,this.debugMode=s.None,this._outlineWidthMode=d.None,this.isOutline=0,this.outlineColorMode=l.MixedLighting,this._cullMode=h.Back,this._outlineCullMode=h.Front,this.outlineCullMode=h.Front,this.storedCullMode=h.Back,this.detailMap=new t.DetailMapConfiguration(this),this._attachImageProcessingConfiguration(null),this.getRenderTargetTextures=()=>(this._renderTargets.reset(),this._eventInfo.renderTargets=this._renderTargets,this._callbackPluginEventFillRenderTargetTextures(this._eventInfo),this._renderTargets),t.Effect.IncludesShadersStore.mtoonUboDeclaration||(t.Effect.IncludesShadersStore.mtoonUboDeclaration="// it will be replaced to UboDeclaration(WebGL2) or VertexDeclaration(WebGL1).\n\nlayout(std140, column_major) uniform;\n\nuniform Material\n{\n    // Color & Texture\n    vec4 vDiffuseColor;\n    vec2 vDiffuseInfos;\n    mat4 diffuseMatrix;\n    vec4 vEmissiveColor;\n    vec2 vEmissiveInfos;\n    mat4 emissiveMatrix;\n    vec3 vBumpInfos;\n    mat4 bumpMatrix;\n    vec3 vShadeColor;\n    vec2 vShadeInfos;\n    mat4 shadeMatrix;\n    vec2 vReceiveShadowInfos;\n    mat4 receiveShadowMatrix;\n    vec2 vShadingGradeInfos;\n    mat4 shadingGradeMatrix;\n    vec3 vRimColor;\n    vec2 vRimInfos;\n    mat4 rimMatrix;\n    vec2 vMatCapInfos;\n    mat4 matCapMatrix;\n    vec4 vOutlineColor;\n    vec2 vOutlineWidthInfos;\n    mat4 outlineWidthMatrix;\n    vec2 vUvAnimationMaskInfos;\n    mat4 uvAnimationMaskMatrix;\n\n    // babylon specific\n    vec2 vTangentSpaceParams;\n    float pointSize;\n\n    // MToon params\n    float shadingGradeRate;\n    float receiveShadowRate;\n    float shadeShift;\n    float shadeToony;\n    float lightColorAttenuation;\n    float indirectLightIntensity;\n    float rimLightingMix;\n    float rimFresnelPower;\n    float rimLift;\n    float outlineWidth;\n    float outlineScaledMaxDistance;\n    float outlineLightingMix;\n    float uvAnimationScrollX;\n    float uvAnimationScrollY;\n    float uvAnimationRotation;\n\n    vec3 vEyeUp;\n    float alphaCutOff;\n    vec3 vAmbientColor;\n    float aspect;\n    float isOutline;\n    vec4 time;\n};\n\n// babylon specific\n#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n",t.Effect.IncludesShadersStore.mtoonVertexDeclaration="// Uniforms\nuniform mat4 viewProjection;\nuniform mat4 view;\nuniform mat4 projection;\nuniform float outlineWidth;\nuniform float outlineScaledMaxDistance;\nuniform float outlineLightingMix;\nuniform float isOutline;\nuniform float aspect;\n\n#ifdef DIFFUSE\nuniform mat4 diffuseMatrix;\nuniform vec2 vDiffuseInfos;\n#endif\n\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\nuniform mat4 emissiveMatrix;\n#endif\n\n#ifdef BUMP\nuniform vec3 vBumpInfos;\nuniform mat4 bumpMatrix;\n#endif\n\n#ifdef SHADE\nuniform vec2 vShadeInfos;\nuniform mat4 shadeMatrix;\n#endif\n\n#ifdef RECEIVE_SHADOW\nuniform vec2 vReceiveShadowInfos;\nuniform mat4 receiveShadowMatrix;\n#endif\n\n#ifdef SHADING_GRADE\nuniform vec2 vShadingGradeInfos;\nuniform mat4 shadingGradeMatrix;\n#endif\n\n#ifdef RIM\nuniform vec2 vRimInfos;\nuniform mat4 rimMatrix;\n#endif\n\n#ifdef MATCAP\nuniform vec2 vMatCapInfos;\nuniform mat4 matCapMatrix;\n#endif\n\n#ifdef OUTLINE_WIDTH\nuniform vec2 vOutlineWidthInfos;\nuniform mat4 outlineWidthMatrix;\n#endif\n\n#ifdef UV_ANIMATION_MASK\nuniform vec2 vUvAnimationMaskInfos;\nuniform mat4 uvAnimationMaskMatrix;\n#endif\n\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n",t.Effect.IncludesShadersStore.mtoonFragmentDeclaration="uniform vec4 vEyePosition;\n\n// Colors\nuniform vec4 vDiffuseColor;\nuniform vec3 vEmissiveColor;\nuniform vec3 vShadeColor;\nuniform vec3 vRimColor;\nuniform vec4 vOutlineColor;\nuniform vec3 vAmbientColor;\n\nuniform vec3 vEyeUp;\nuniform float aspect;\nuniform float alphaCutOff;\nuniform float visibility;\nuniform float isOutline;\nuniform vec4 time;\n\n// Samplers\n#ifdef DIFFUSE\nuniform vec2 vDiffuseInfos;\n#endif\n\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\n#endif\n\n#ifdef BUMP\nuniform vec3 vBumpInfos;\nuniform vec2 vTangentSpaceParams;\n#endif\n\n#ifdef SHADE\nuniform vec2 vShadeInfos;\n#endif\n\n#ifdef RECEIVE_SHADOW\nuniform vec2 vReceiveShadowInfos;\n#endif\n\n#ifdef SHADING_GRADE\nuniform vec2 vShadingGradeInfos;\n#endif\n\n#ifdef RIM\nuniform vec2 vRimInfos;\n#endif\n\n#ifdef MATCAP\nuniform vec2 vMatCapInfos;\n#endif\n\n#ifdef OUTLINE_WIDTH\nuniform vec2 vOutlineWidthInfos;\n#endif\n\n#ifdef UV_ANIMATION_MASK\nuniform vec2 vUvAnimationMaskInfos;\n#endif\n\n// MToon params\nuniform float shadingGradeRate;\nuniform float receiveShadowRate;\nuniform float shadeShift;\nuniform float shadeToony;\nuniform float lightColorAttenuation;\nuniform float indirectLightIntensity;\nuniform float rimLightingMix;\nuniform float rimFresnelPower;\nuniform float rimLift;\nuniform float outlineWidth;\nuniform float outlineScaledMaxDistance;\nuniform float outlineLightingMix;\nuniform float uvAnimationScrollX;\nuniform float uvAnimationScrollY;\nuniform float uvAnimationRotation;\n",t.Effect.IncludesShadersStore.mtoonFragmentFunctions="\n/**\n* Compute Directional or Point light direction\n*/\nvec3 computeLightDirection(vec4 lightData) {\n    return normalize(mix(lightData.xyz - vPositionW, -lightData.xyz, lightData.w));\n}\n\n/**\n* Compute Spot Light direction\n*/\nvec3 computeSpotLightDirection(vec4 lightData) {\n    return normalize(lightData.xyz - vPositionW);\n}\n\n/**\n* Compute Hemispheric light direction\n*/\nvec3 computeHemisphericLightDirection(vec4 lightData, vec3 vNormal) {\n    return normalize(lightData.xyz);\n}\n\n/**\n* Compute MToon diffuse lighting\n*/\nvec4 computeMToonDiffuseLighting(vec3 worldView, vec3 worldNormal, vec2 mainUv, vec3 lightDirection, vec4 lightDiffuse, float shadowAttenuation) {\n    float _receiveShadow = receiveShadowRate;\n#ifdef RECEIVE_SHADOW\n    _receiveShadow = _receiveShadow * texture2D(receiveShadowSampler, mainUv).r * vReceiveShadowInfos.y;\n#endif\n\n    float _shadingGrade = 0.0;\n#ifdef SHADING_GRADE\n    _shadingGrade = 1.0 - texture2D(shadingGradeSampler, mainUv).r * vShadingGradeInfos.y;\n#endif\n    _shadingGrade = 1.0 - shadingGradeRate * _shadingGrade;\n\n    // Lighting\n    vec3 _lightColor = lightDiffuse.rgb * step(0.5, length(lightDirection)); // length(lightDir) is zero if directional light is disabled.\n    float _dotNL = dot(lightDirection, worldNormal);\n#ifdef MTOON_FORWARD_ADD\n    float _lightAttenuation = 1.0;\n#else\n    float _lightAttenuation = shadowAttenuation * mix(1.0, shadowAttenuation, _receiveShadow);\n#endif\n\n    // lighting intensity\n    float _lightIntensity = _dotNL;\n    _lightIntensity = _lightIntensity * 0.5 + 0.5; // from [-1, +1] to [0, 1]\n    _lightIntensity = _lightIntensity * _lightAttenuation; // receive shadow\n    _lightIntensity = _lightIntensity * _shadingGrade; // darker\n    _lightIntensity = _lightIntensity * 2.0 - 1.0; // from [0, 1] to [-1, +1]\n    // tooned. mapping from [minIntensityThreshold, maxIntensityThreshold] to [0, 1]\n    float _maxIntensityThreshold = mix(1.0, shadeShift, shadeToony);\n    float _minIntensityThreshold = shadeShift;\n    _lightIntensity = clamp((_lightIntensity - _minIntensityThreshold) / max(EPS_COL, (_maxIntensityThreshold - _minIntensityThreshold)), 0.0, 1.0);\n\n    // Albedo color\n    vec3 _shade = vShadeColor;\n#ifdef SHADE\n    _shade = _shade * texture2D(shadeSampler, mainUv).rgb * vShadeInfos.y;\n#endif\n\n    vec4 _lit = vDiffuseColor;\n#ifdef DIFFUSE\n    _lit = _lit * texture2D(diffuseSampler, mainUv) * vDiffuseInfos.y;\n#endif\n    vec3 _col = mix(_shade.rgb, _lit.rgb, _lightIntensity);\n\n    // Direct Light\n    vec3 _lighting = _lightColor;\n    _lighting = mix(_lighting, vec3(max(EPS_COL, max(_lighting.x, max(_lighting.y, _lighting.z)))), lightColorAttenuation); // color atten\n#ifdef MTOON_FORWARD_ADD\n    _lighting *= 0.5; // darken if additional light\n    _lighting *= min(0, dotNL) + 1.0; // darken dotNL < 0 area by using half lambert\n    _lighting *= shadowAttenuation; // darken if receiving shadow\n#else\n    // base light does not darken.\n#endif\n    _col *= _lighting;\n\n    // Indirect Light\n#ifdef MTOON_FORWARD_ADD\n#else\n    vec3 _toonedGI = vAmbientColor.rgb; // TODO: GI\n    vec3 _indirectLighting = mix(_toonedGI, vAmbientColor.rgb, indirectLightIntensity);\n    _indirectLighting = mix(_indirectLighting, vec3(max(EPS_COL, max(_indirectLighting.x, max(_indirectLighting.y, _indirectLighting.z)))), lightColorAttenuation); // color atten\n    _col += _indirectLighting * _lit.rgb;\n\n    _col = min(_col.rgb, _lit.rgb); // comment out if you want to PBR absolutely.\n#endif\n\n    // parametric rim lighting\n#ifdef MTOON_FORWARD_ADD\n    vec3 _staticRimLighting = vec3(0.0);\n    vec3 _mixedRimLighting = _lighting;\n#else\n    vec3 _staticRimLighting = vec3(1.0);\n    vec3 _mixedRimLighting = _lighting + _indirectLighting;\n#endif\n    vec3 _rimLighting = mix(_staticRimLighting, _mixedRimLighting, rimLightingMix);\n    vec3 _rimColor = vRimColor.rgb;\n#ifdef RIM\n    _rimColor = _rimColor * texture2D(rimSampler, vRimUV + mainUv).rgb * vRimInfos.y;\n#endif\n    vec3 _rim = pow(clamp(1.0 - dot(worldNormal, worldView) + rimLift, 0.0, 1.0), rimFresnelPower) * _rimColor.rgb;\n    _col += mix(_rim * _rimLighting, vec3(0.0), isOutline);\n\n    // additive matcap\n#ifdef MTOON_FORWARD_ADD\n#else\n#ifdef MATCAP\n    vec3 _worldViewUp = normalize(vEyeUp - worldView * dot(worldView, vEyeUp));\n    vec3 _worldViewRight = normalize(cross(worldView, _worldViewUp));\n    vec2 _matCapUv = vec2(dot(_worldViewRight, worldNormal), dot(_worldViewUp, worldNormal)) * 0.5 + 0.5;\n    // uv.y is reversed\n    _matCapUv.y = (1.0 - _matCapUv.y);\n    vec3 _matCapLighting = texture2D(matCapSampler, _matCapUv).rgb * vMatCapInfos.y;\n    _col += mix(_matCapLighting, vec3(0.0), isOutline);\n#endif\n#endif\n\n    // Emission\n#ifdef MTOON_FORWARD_ADD\n#else\n    vec3 _emission = vEmissiveColor.rgb;\n#ifdef EMISSIVE\n    _emission *= texture2D(emissiveSampler, mainUv).rgb * vEmissiveInfos.y;\n#endif\n    _col += mix(_emission, vec3(0.0), isOutline);\n#endif\n\n    float _alpha = 1.0;\n\n#if defined(ALPHABLEND) || defined(ALPHATEST)\n    _alpha = mix(_lit.a, _lit.a * vOutlineColor.a, isOutline);\n#endif\n\n    // outline\n#ifdef MTOON_OUTLINE_COLOR_FIXED\n    _col = mix(_col, vOutlineColor.rgb, isOutline);\n#elif defined(MTOON_OUTLINE_COLOR_MIXED)\n    _col = mix(_col, vOutlineColor.rgb * mix(vec3(1.0), _col, outlineLightingMix), isOutline);\n#else\n#endif\n\n    // debug\n#ifdef MTOON_DEBUG_NORMAL\n    #ifdef MTOON_FORWARD_ADD\n        return vec4(0.0);\n    #else\n        return vec4(worldNormal * 0.5 + 0.5, _lit.a);\n    #endif\n#elif defined(MTOON_DEBUG_LITSHADERATE)\n    #ifdef MTOON_FORWARD_ADD\n        return vec4(0.0);\n    #else\n        return vec4(_lightIntensity, _lit.a);\n    #endif\n#endif\n\n    return vec4(_col, _alpha);\n}\n",t.Effect.IncludesShadersStore.mtoonLightFragment="#ifdef LIGHT{X}\n    #if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})\n        //No light calculation\n    #else\n        #ifdef PBR\n            // Compute Pre Lighting infos\n            #ifdef SPOTLIGHT{X}\n                preInfo = computePointAndSpotPreLightingInfo(light{X}.vLightData, viewDirectionW, normalW);\n            #elif defined(POINTLIGHT{X})\n                preInfo = computePointAndSpotPreLightingInfo(light{X}.vLightData, viewDirectionW, normalW);\n            #elif defined(HEMILIGHT{X})\n                preInfo = computeHemisphericPreLightingInfo(light{X}.vLightData, viewDirectionW, normalW);\n            #elif defined(DIRLIGHT{X})\n                preInfo = computeDirectionalPreLightingInfo(light{X}.vLightData, viewDirectionW, normalW);\n            #endif\n\n            preInfo.NdotV = NdotV;\n\n            // Compute Attenuation infos\n            #ifdef SPOTLIGHT{X}\n                #ifdef LIGHT_FALLOFF_GLTF{X}\n                    preInfo.attenuation = computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared, light{X}.vLightFalloff.y);\n                    preInfo.attenuation *= computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz, preInfo.L, light{X}.vLightFalloff.z, light{X}.vLightFalloff.w);\n                #elif defined(LIGHT_FALLOFF_PHYSICAL{X})\n                    preInfo.attenuation = computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\n                    preInfo.attenuation *= computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz, preInfo.L, light{X}.vLightDirection.w);\n                #elif defined(LIGHT_FALLOFF_STANDARD{X})\n                    preInfo.attenuation = computeDistanceLightFalloff_Standard(preInfo.lightOffset, light{X}.vLightFalloff.x);\n                    preInfo.attenuation *= computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz, preInfo.L, light{X}.vLightDirection.w, light{X}.vLightData.w);\n                #else\n                    preInfo.attenuation = computeDistanceLightFalloff(preInfo.lightOffset, preInfo.lightDistanceSquared, light{X}.vLightFalloff.x, light{X}.vLightFalloff.y);\n                    preInfo.attenuation *= computeDirectionalLightFalloff(light{X}.vLightDirection.xyz, preInfo.L, light{X}.vLightDirection.w, light{X}.vLightData.w, light{X}.vLightFalloff.z, light{X}.vLightFalloff.w);\n                #endif\n            #elif defined(POINTLIGHT{X})\n                #ifdef LIGHT_FALLOFF_GLTF{X}\n                    preInfo.attenuation = computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared, light{X}.vLightFalloff.y);\n                #elif defined(LIGHT_FALLOFF_PHYSICAL{X})\n                    preInfo.attenuation = computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\n                #elif defined(LIGHT_FALLOFF_STANDARD{X})\n                    preInfo.attenuation = computeDistanceLightFalloff_Standard(preInfo.lightOffset, light{X}.vLightFalloff.x);\n                #else\n                    preInfo.attenuation = computeDistanceLightFalloff(preInfo.lightOffset, preInfo.lightDistanceSquared, light{X}.vLightFalloff.x, light{X}.vLightFalloff.y);\n                #endif\n            #else\n                preInfo.attenuation = 1.0;\n            #endif\n\n            // Simulates Light radius for diffuse and spec term\n            // clear coat is using a dedicated roughness\n            #ifdef HEMILIGHT{X}\n                preInfo.roughness = roughness;\n            #else\n                preInfo.roughness = adjustRoughnessFromLightProperties(roughness, light{X}.vLightSpecular.a, preInfo.lightDistance);\n            #endif\n\n            // Diffuse contribution\n            #ifdef HEMILIGHT{X}\n                info.diffuse = computeHemisphericDiffuseLighting(preInfo, light{X}.vLightDiffuse.rgb, light{X}.vLightGround);\n            #elif defined(SS_TRANSLUCENCY)\n                info.diffuse = computeDiffuseAndTransmittedLighting(preInfo, light{X}.vLightDiffuse.rgb, subSurfaceOut.transmittance);\n            #else\n                info.diffuse = computeDiffuseLighting(preInfo, light{X}.vLightDiffuse.rgb);\n            #endif\n\n            // Specular contribution\n            #ifdef SPECULARTERM\n                #ifdef ANISOTROPIC\n                    info.specular = computeAnisotropicSpecularLighting(preInfo, viewDirectionW, normalW, anisotropicOut.anisotropicTangent, anisotropicOut.anisotropicBitangent, anisotropicOut.anisotropy, clearcoatOut.specularEnvironmentR0, specularEnvironmentR90, AARoughnessFactors.x, light{X}.vLightDiffuse.rgb);\n                #else\n                    info.specular = computeSpecularLighting(preInfo, normalW, clearcoatOut.specularEnvironmentR0, specularEnvironmentR90, AARoughnessFactors.x, light{X}.vLightDiffuse.rgb);\n                #endif\n            #endif\n\n            // Sheen contribution\n            #ifdef SHEEN\n                #ifdef SHEEN_LINKWITHALBEDO\n                    // BE Carefull: Sheen intensity is replacing the roughness value.\n                    preInfo.roughness = sheenOut.sheenIntensity;\n                #else\n                    #ifdef HEMILIGHT{X}\n                        preInfo.roughness = sheenOut.sheenRoughness;\n                    #else\n                        preInfo.roughness = adjustRoughnessFromLightProperties(sheenOut.sheenRoughness, light{X}.vLightSpecular.a, preInfo.lightDistance);\n                    #endif\n                #endif\n                info.sheen = computeSheenLighting(preInfo, normalW, sheenOut.sheenColor, specularEnvironmentR90, AARoughnessFactors.x, light{X}.vLightDiffuse.rgb);\n            #endif\n\n            // Clear Coat contribution\n            #ifdef CLEARCOAT\n                // Simulates Light radius\n                #ifdef HEMILIGHT{X}\n                    preInfo.roughness = clearcoatOut.clearCoatRoughness;\n                #else\n                    preInfo.roughness = adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness, light{X}.vLightSpecular.a, preInfo.lightDistance);\n                #endif\n\n                info.clearCoat = computeClearCoatLighting(preInfo, clearcoatOut.clearCoatNormalW, clearcoatOut.clearCoatAARoughnessFactors.x, clearcoatOut.clearCoatIntensity, light{X}.vLightDiffuse.rgb);\n\n                #ifdef CLEARCOAT_TINT\n                    // Absorption\n                    absorption = computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract, preInfo.L, clearcoatOut.clearCoatNormalW, clearcoatOut.clearCoatColor, clearcoatOut.clearCoatThickness, clearcoatOut.clearCoatIntensity);\n                    info.diffuse *= absorption;\n                    #ifdef SPECULARTERM\n                        info.specular *= absorption;\n                    #endif\n                #endif\n\n                // Apply energy conservation on diffuse and specular term.\n                info.diffuse *= info.clearCoat.w;\n                #ifdef SPECULARTERM\n                    info.specular *= info.clearCoat.w;\n                #endif\n                #ifdef SHEEN\n                    info.sheen *= info.clearCoat.w;\n                #endif\n            #endif\n        #else\n            #ifdef SPOTLIGHT{X}\n                info = computeSpotLighting(viewDirectionW, normalW, light{X}.vLightData, light{X}.vLightDirection, light{X}.vLightDiffuse.rgb, light{X}.vLightSpecular.rgb, light{X}.vLightDiffuse.a, glossiness);\n            #elif defined(HEMILIGHT{X})\n                info = computeHemisphericLighting(viewDirectionW, normalW, light{X}.vLightData, light{X}.vLightDiffuse.rgb, light{X}.vLightSpecular.rgb, light{X}.vLightGround, glossiness);\n            #elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\n                info = computeLighting(viewDirectionW, normalW, light{X}.vLightData, light{X}.vLightDiffuse.rgb, light{X}.vLightSpecular.rgb, light{X}.vLightDiffuse.a, glossiness);\n            #endif\n        #endif\n\n        #ifdef PROJECTEDLIGHTTEXTURE{X}\n            info.diffuse *= computeProjectionTextureDiffuseLighting(projectionLightSampler{X}, textureProjectionMatrix{X});\n        #endif\n    #endif\n\n    #ifdef SHADOW{X}\n        #ifdef SHADOWCSM{X}\n            for (int i = 0; i < SHADOWCSMNUM_CASCADES{X}; i++)\n            {\n                #ifdef SHADOWCSM_RIGHTHANDED{X}\n                    diff{X} = viewFrustumZ{X}[i] + vPositionFromCamera{X}.z;\n                #else\n                    diff{X} = viewFrustumZ{X}[i] - vPositionFromCamera{X}.z;\n                #endif\n                if (diff{X} >= 0.) {\n                    index{X} = i;\n                    break;\n                }\n            }\n\n            #ifdef SHADOWCSMUSESHADOWMAXZ{X}\n            if (index{X} >= 0)\n            #endif\n            {\n                #if defined(SHADOWPCF{X})\n                    #if defined(SHADOWLOWQUALITY{X})\n                        shadow = computeShadowWithCSMPCF1(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                    #elif defined(SHADOWMEDIUMQUALITY{X})\n                        shadow = computeShadowWithCSMPCF3(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                    #else\n                        shadow = computeShadowWithCSMPCF5(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                    #endif\n                #elif defined(SHADOWPCSS{X})\n                    #if defined(SHADOWLOWQUALITY{X})\n                        shadow = computeShadowWithCSMPCSS16(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w, lightSizeUVCorrection{X}[index{X}], depthCorrection{X}[index{X}], penumbraDarkness{X});\n                    #elif defined(SHADOWMEDIUMQUALITY{X})\n                        shadow = computeShadowWithCSMPCSS32(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w, lightSizeUVCorrection{X}[index{X}], depthCorrection{X}[index{X}], penumbraDarkness{X});\n                    #else\n                        shadow = computeShadowWithCSMPCSS64(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w, lightSizeUVCorrection{X}[index{X}], depthCorrection{X}[index{X}], penumbraDarkness{X});\n                    #endif\n                #else\n                    shadow = computeShadowCSM(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                #endif\n\n                #ifdef SHADOWCSMDEBUG{X}\n                    shadowDebug{X} = vec3(shadow) * vCascadeColorsMultiplier{X}[index{X}];\n                #endif\n\n                #ifndef SHADOWCSMNOBLEND{X}\n                    float frustumLength = frustumLengths{X}[index{X}];\n                    float diffRatio = clamp(diff{X} / frustumLength, 0., 1.) * cascadeBlendFactor{X};\n                    if (index{X} < (SHADOWCSMNUM_CASCADES{X} - 1) && diffRatio < 1.)\n                    {\n                        index{X} += 1;\n                        float nextShadow = 0.;\n                        #if defined(SHADOWPCF{X})\n                            #if defined(SHADOWLOWQUALITY{X})\n                                nextShadow = computeShadowWithCSMPCF1(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                            #elif defined(SHADOWMEDIUMQUALITY{X})\n                                nextShadow = computeShadowWithCSMPCF3(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                            #else\n                                nextShadow = computeShadowWithCSMPCF5(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                            #endif\n                        #elif defined(SHADOWPCSS{X})\n                            #if defined(SHADOWLOWQUALITY{X})\n                                nextShadow = computeShadowWithCSMPCSS16(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w, lightSizeUVCorrection{X}[index{X}], depthCorrection{X}[index{X}], penumbraDarkness{X});\n                            #elif defined(SHADOWMEDIUMQUALITY{X})\n                                nextShadow = computeShadowWithCSMPCSS32(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w, lightSizeUVCorrection{X}[index{X}], depthCorrection{X}[index{X}], penumbraDarkness{X});\n                            #else\n                                nextShadow = computeShadowWithCSMPCSS64(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w, lightSizeUVCorrection{X}[index{X}], depthCorrection{X}[index{X}], penumbraDarkness{X});\n                            #endif\n                        #else\n                            nextShadow = computeShadowCSM(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                        #endif\n\n                        shadow = mix(nextShadow, shadow, diffRatio);\n                        #ifdef SHADOWCSMDEBUG{X}\n                            shadowDebug{X} = mix(vec3(nextShadow) * vCascadeColorsMultiplier{X}[index{X}], shadowDebug{X}, diffRatio);\n                        #endif\n                    }\n                #endif\n            }\n        #elif defined(SHADOWCLOSEESM{X})\n            #if defined(SHADOWCUBE{X})\n                shadow = computeShadowWithCloseESMCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.depthValues);\n            #else\n                shadow = computeShadowWithCloseESM(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.shadowsInfo.w);\n            #endif\n        #elif defined(SHADOWESM{X})\n            #if defined(SHADOWCUBE{X})\n                shadow = computeShadowWithESMCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.depthValues);\n            #else\n                shadow = computeShadowWithESM(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.shadowsInfo.w);\n            #endif\n        #elif defined(SHADOWPOISSON{X})\n            #if defined(SHADOWCUBE{X})\n                shadow = computeShadowWithPoissonSamplingCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.x, light{X}.depthValues);\n            #else\n                shadow = computeShadowWithPoissonSampling(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #endif\n        #elif defined(SHADOWPCF{X})\n            #if defined(SHADOWLOWQUALITY{X})\n                shadow = computeShadowWithPCF1(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #elif defined(SHADOWMEDIUMQUALITY{X})\n                shadow = computeShadowWithPCF3(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #else\n                shadow = computeShadowWithPCF5(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #endif\n        #elif defined(SHADOWPCSS{X})\n            #if defined(SHADOWLOWQUALITY{X})\n                shadow = computeShadowWithPCSS16(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #elif defined(SHADOWMEDIUMQUALITY{X})\n                shadow = computeShadowWithPCSS32(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #else\n                shadow = computeShadowWithPCSS64(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #endif\n        #else\n            #if defined(SHADOWCUBE{X})\n                shadow = computeShadowCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.depthValues);\n            #else\n                shadow = computeShadow(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #endif\n        #endif\n\n        #ifdef SHADOWONLY\n            #ifndef SHADOWINUSE\n                #define SHADOWINUSE\n            #endif\n            globalShadow += shadow;\n            shadowLightCount += 1.0;\n        #endif\n    #else\n        shadow = 1.;\n    #endif\n\n    #ifndef SHADOWONLY\n        #ifdef CUSTOMUSERLIGHTING\n            // Compute and reflect MToon lighting\n            #ifdef SPOTLIGHT{X}\n                lightDirection = computeSpotLightDirection(light{X}.vLightData);\n            #elif defined(HEMILIGHT{X})\n                lightDirection = computeHemisphericLightDirection(light{X}.vLightData, normalW.xyz);\n            #elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\n                lightDirection = computeLightDirection(light{X}.vLightData);\n            #endif\n            mtoonDiffuse = computeMToonDiffuseLighting(viewDirectionW.xyz, normalW.xyz, mainUv, lightDirection, light{X}.vLightDiffuse.rgba, shadow);\n            diffuseBase += mtoonDiffuse.rgb;\n            alpha = min(alpha, mtoonDiffuse.a);\n            #if defined(ALPHATEST) && ALPHATEST\n                alpha = (alpha - alphaCutOff) / max(fwidth(alpha), EPS_COL) + 0.5; // Alpha to Coverage\n                if (alpha < alphaCutOff) {\n                    discard;\n                }\n                alpha = 1.0; // Discarded, otherwise it should be assumed to have full opacity\n            #else\n                if (alpha - 0.0001 < 0.000) { // Slightly improves rendering with layered transparency\n                    discard;\n                }\n            #endif\n        #elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})\n            diffuseBase += lightmapColor.rgb * shadow;\n            #ifdef SPECULARTERM\n                #ifndef LIGHTMAPNOSPECULAR{X}\n                    specularBase += info.specular * shadow * lightmapColor.rgb;\n                #endif\n            #endif\n            #ifdef CLEARCOAT\n                #ifndef LIGHTMAPNOSPECULAR{X}\n                    clearCoatBase += info.clearCoat.rgb * shadow * lightmapColor.rgb;\n                #endif\n            #endif\n            #ifdef SHEEN\n                #ifndef LIGHTMAPNOSPECULAR{X}\n                    sheenBase += info.sheen.rgb * shadow;\n                #endif\n            #endif\n        #else\n            #ifdef SHADOWCSMDEBUG{X}\n                diffuseBase += info.diffuse * shadowDebug{X};\n            #else\n                diffuseBase += info.diffuse * shadow;\n            #endif\n            #ifdef SPECULARTERM\n                specularBase += info.specular * shadow;\n            #endif\n            #ifdef CLEARCOAT\n                clearCoatBase += info.clearCoat.rgb * shadow;\n            #endif\n            #ifdef SHEEN\n                sheenBase += info.sheen.rgb * shadow;\n            #endif\n        #endif\n    #endif\n#endif\n",t.Effect.IncludesShadersStore.mtoonBumpFragment="// replace vBumpUV to mainUv\nvec2 uvOffset = vec2(0.0, 0.0);\n\n#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)\n    #ifdef NORMALXYSCALE\n        float normalScale = 1.0;\n    #elif defined(BUMP)\n        float normalScale = vBumpInfos.y;\n    #else\n        float normalScale = 1.0;\n    #endif\n\n    #if defined(TANGENT) && defined(NORMAL)\n        mat3 TBN = vTBN;\n    #elif defined(BUMP)\n        // vec2 TBNUV = gl_FrontFacing ? vBumpUV : -vBumpUV;\n        vec2 TBNUV = gl_FrontFacing ? mainUv : -mainUv;\n        mat3 TBN = cotangent_frame(normalW * normalScale, vPositionW, TBNUV, vTangentSpaceParams);\n    #else\n        vec2 TBNUV = gl_FrontFacing ? vDetailUV : -vDetailUV;\n        mat3 TBN = cotangent_frame(normalW * normalScale, vPositionW, TBNUV, vec2(1., 1.));\n    #endif\n#elif defined(ANISOTROPIC)\n    #if defined(TANGENT) && defined(NORMAL)\n        mat3 TBN = vTBN;\n    #else\n        // flip the uv for the backface\n        vec2 TBNUV = gl_FrontFacing ? vMainUV1 : -vMainUV1;\n        mat3 TBN = cotangent_frame(normalW, vPositionW, TBNUV, vec2(1., 1.));\n    #endif\n#endif\n\n#ifdef PARALLAX\n    mat3 invTBN = transposeMat3(TBN);\n\n    #ifdef PARALLAXOCCLUSION\n        // uvOffset = parallaxOcclusion(invTBN * -viewDirectionW, invTBN * normalW, vBumpUV, vBumpInfos.z);\n        uvOffset = parallaxOcclusion(invTBN * -viewDirectionW, invTBN * normalW, mainUv, vBumpInfos.z);\n    #else\n        uvOffset = parallaxOffset(invTBN * viewDirectionW, vBumpInfos.z);\n    #endif\n#endif\n\n#ifdef DETAIL\n    vec4 detailColor = texture2D(detailSampler, vDetailUV + uvOffset);\n    vec2 detailNormalRG = detailColor.wy * 2.0 - 1.0;\n    float detailNormalB = sqrt(1. - saturate(dot(detailNormalRG, detailNormalRG)));\n    vec3 detailNormal = vec3(detailNormalRG, detailNormalB);\n#endif\n\n#ifdef BUMP\n    #ifdef OBJECTSPACE_NORMALMAP\n        // normalW = normalize(texture2D(bumpSampler, vBumpUV).xyz  * 2.0 - 1.0);\n        normalW = normalize(texture2D(bumpSampler, mainUv).xyz  * 2.0 - 1.0);\n        normalW = normalize(mat3(normalMatrix) * normalW);\n    #elif !defined(DETAIL)\n        // normalW = perturbNormal(TBN, texture2D(bumpSampler, vBumpUV + uvOffset).xyz, vBumpInfos.y);\n        normalW = perturbNormal(TBN, texture2D(bumpSampler, mainUv + uvOffset).xyz, vBumpInfos.y);\n    #else\n        // vec3 bumpNormal = texture2D(bumpSampler, vBumpUV + uvOffset).xyz * 2.0 - 1.0;\n        vec3 bumpNormal = texture2D(bumpSampler, mainUv + uvOffset).xyz * 2.0 - 1.0;\n        // Reference for normal blending: https://blog.selfshadow.com/publications/blending-in-detail/\n        #if DETAIL_NORMALBLENDMETHOD == 0 // whiteout\n            detailNormal.xy *= vDetailInfos.z;\n            vec3 blendedNormal = normalize(vec3(bumpNormal.xy + detailNormal.xy, bumpNormal.z * detailNormal.z));\n        #elif DETAIL_NORMALBLENDMETHOD == 1 // RNM\n            detailNormal.xy *= vDetailInfos.z;\n            bumpNormal += vec3(0.0, 0.0, 1.0);\n            detailNormal *= vec3(-1.0, -1.0, 1.0);\n            vec3 blendedNormal = bumpNormal * dot(bumpNormal, detailNormal) / bumpNormal.z - detailNormal;\n        #endif\n        normalW = perturbNormalBase(TBN, blendedNormal, vBumpInfos.y);\n    #endif\n#elif defined(DETAIL)\n        detailNormal.xy *= vDetailInfos.z;\n        normalW = perturbNormalBase(TBN, detailNormal, vDetailInfos.z);\n#endif\n",t.Effect.ShadersStore.mtoonVertexShader="// it is based on default.vertex.fx\n// This include is special, it will be replaced to UboDeclaration(WebGL2) or VertexDeclaration(WebGL1).\n// @see effect.ts\n#include<__decl__mtoonVertex>\n\n// Attributes\n\n#define CUSTOM_VERTEX_BEGIN\n\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef TANGENT\nattribute vec4 tangent;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#include<uvAttributeDeclaration>[2..7]\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n\n#include<helperFunctions>\n\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n\n// Uniforms\n#include<instancesDeclaration>\n#include<prePassVertexDeclaration>\n\n#include<mainUVVaryingDeclaration>[1..7]\n\n#include<samplerVertexDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse)\n// # include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)\n// # include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)\n// # include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)\n// # include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)\n// # if defined(SPECULARTERM)\n// # include<samplerVertexDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular)\n// # endif\n#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SHADE,_VARYINGNAME_,Shade)\n#include<samplerVertexDeclaration>(_DEFINENAME_,RECEIVE_SHADOW,_VARYINGNAME_,ReceiveShadow)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SHADING_GRADE,_VARYINGNAME_,ShadingGrade)\n#include<samplerVertexDeclaration>(_DEFINENAME_,RIM,_VARYINGNAME_,Rim)\n#include<samplerVertexDeclaration>(_DEFINENAME_,MATCAP,_VARYINGNAME_,MatCap)\n#include<samplerVertexDeclaration>(_DEFINENAME_,OUTLINE_WIDTH,_VARYINGNAME_,OutlineWidth)\n#include<samplerVertexDeclaration>(_DEFINENAME_,UV_ANIMATION_MASK,_VARYINGNAME_,UvAnimationMask)\n\n// Additional Uniforms\n#ifdef OUTLINE_WIDTH\n    uniform sampler2D outlineWidthSampler;\n#endif\n\n// Output\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)\nvarying vec4 vColor;\n#endif\n\n#include<bumpVertexDeclaration>\n\n#include<clipPlaneVertexDeclaration>\n\n#include<fogVertexDeclaration>\n#include<__decl__lightVxFragment>[0..maxSimultaneousLights]\n\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n\n// # ifdef REFLECTIONMAP_SKYBOX\n// varying vec3 vPositionUVW;\n// # endif\n\n// # if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\n// varying vec3 vDirectionW;\n// # endif\n\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\n\nvoid main(void) {\n\n    #define CUSTOM_VERTEX_MAIN_BEGIN\n\n    vec3 positionUpdated = position;\n#ifdef NORMAL\n    vec3 normalUpdated = normal;\n#endif\n#ifdef TANGENT\n    vec4 tangentUpdated = tangent;\n#endif\n#ifdef UV1\n    vec2 uvUpdated = uv;\n#endif\n\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n\n// # ifdef REFLECTIONMAP_SKYBOX\n//     vPositionUVW = positionUpdated;\n// # endif\n\n#define CUSTOM_VERTEX_UPDATE_POSITION\n\n#define CUSTOM_VERTEX_UPDATE_NORMAL\n\n#include<instancesVertex>\n\n#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)\n    // Compute velocity before bones computation\n    vCurrentPosition = viewProjection * finalWorld * vec4(positionUpdated, 1.0);\n    vPreviousPosition = previousViewProjection * finalPreviousWorld * vec4(positionUpdated, 1.0);\n#endif\n\n#include<bonesVertex>\n#include<bakedVertexAnimation>\n\n    // Texture coordinates\n#ifndef UV1\n    vec2 uvUpdated = vec2(0., 0.);\n#endif\n#ifdef MAINUV1\n    vMainUV1 = uvUpdated;\n#endif\n#include<uvVariableDeclaration>[2..7]\n\n    float outlineTex = 1.0;\n    if (isOutline == 1.0) {\n#ifdef OUTLINE_WIDTH\n    #if OUTLINE_WIDTHDIRECTUV == 0\n        if (vOutlineWidthInfos.x == 0.)\n        {\n            vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uvUpdated, 1.0, 0.0));\n        }\n        #ifdef UV2\n        else if (vOutlineWidthInfos.x == 1.)\n        {\n            vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uv2, 1.0, 0.0));\n        }\n        #endif\n        #ifdef UV3\n        else if (vOutlineWidthInfos.x == 2.)\n        {\n            vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uv3, 1.0, 0.0));\n        }\n        #endif\n        #ifdef UV4\n        else if (vOutlineWidthInfos.x == 3.)\n        {\n            vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uv4, 1.0, 0.0));\n        }\n        #endif\n        #ifdef UV5\n        else if (vOutlineWidthInfos.x == 4.)\n        {\n            vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uv5, 1.0, 0.0));\n        }\n        #endif\n        #ifdef UV6\n        else if (vOutlineWidthInfos.x == 5.)\n        {\n            vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uv6, 1.0, 0.0));\n        }\n        #endif\n    #elif defined(MAINUV1)\n        vec2 vOutlineWidthUV = vMainUV1;\n    #elif defined(MAINUV2)\n        vec2 vOutlineWidthUV = vMainUV2;\n    #else\n        vec2 vOutlineWidthUV = vec2(0., 0.);\n    #endif\n        outlineTex = texture2D(outlineWidthSampler, vOutlineWidthUV).r * vOutlineWidthInfos.y;\n#endif\n\n#if defined(MTOON_OUTLINE_WIDTH_WORLD) && defined(NORMAL)\n        // move slightly world normal\n        vec3 outlineOffset = 0.01 * outlineWidth * outlineTex * length(transposeMat3(inverseMat3(mat3(finalWorld))) * normalUpdated) * normalUpdated;\n        positionUpdated += outlineOffset;\n#endif\n    } // End isOutline == 1.0\n\n    vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);\n\n#ifdef NORMAL\n    mat3 normalWorld = mat3(finalWorld);\n\n    #if defined(INSTANCES) && defined(THIN_INSTANCES)\n        vNormalW = normalUpdated / vec3(dot(normalWorld[0], normalWorld[0]), dot(normalWorld[1], normalWorld[1]), dot(normalWorld[2], normalWorld[2]));\n        vNormalW = normalize(normalWorld * vNormalW);\n    #else\n        #ifdef NONUNIFORMSCALING\n            normalWorld = transposeMat3(inverseMat3(normalWorld));\n        #endif\n\n        vNormalW = normalize(normalWorld * normalUpdated);\n    #endif\n#endif\n\n#define CUSTOM_VERTEX_UPDATE_WORLDPOS\n\n#ifdef MULTIVIEW\n    if (gl_ViewID_OVR == 0u) {\n        gl_Position = viewProjection * worldPos;\n    } else {\n        gl_Position = viewProjectionR * worldPos;\n    }\n#else\n    gl_Position = viewProjection * worldPos;\n#endif\n\n    if (isOutline == 1.0) {\n#if defined(MTOON_OUTLINE_WIDTH_SCREEN) && defined(NORMAL)\n        vec3 viewNormal = transposeMat3(inverseMat3(mat3(view) * mat3(finalWorld))) * normalUpdated;\n        vec3 clipNormal = mat3(projection) * viewNormal;\n        vec2 projectedNormal = normalize(clipNormal.xy);\n        projectedNormal *= min(gl_Position.w, outlineScaledMaxDistance);\n        projectedNormal.x /= aspect; // aspect in original mtoon is y/x. aspect in babylon is x/y.\n        gl_Position.xy += 0.01 * outlineWidth * outlineTex * projectedNormal * clamp(1.0 - abs(normalize(viewNormal).z), 0.0, 1.0); // ignore offset when normal toward camera\n#endif\n\n        gl_Position.z += 1E-6 * gl_Position.w; // anti-artifact magic from three-vrm\n    }\n\n    worldPos = finalWorld * vec4(positionUpdated, 1.0);\n    vPositionW = vec3(worldPos);\n\n#include<prePassVertex>\n\n// # if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\n//     vDirectionW = normalize(vec3(finalWorld * vec4(positionUpdated, 0.0)));\n// # endif\n\n    #include<samplerVertexImplementation>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_MATRIXNAME_,diffuse,_INFONAME_,DiffuseInfos.x)\n    // # include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)\n    // # include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)\n    // # include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)\n    // # include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)\n    // # if defined(SPECULARTERM)\n    // # include<samplerVertexImplementation>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_MATRIXNAME_,specular,_INFONAME_,SpecularInfos.x)\n    // # endif\n    #include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,SHADE,_VARYINGNAME_,Shade,_MATRIXNAME_,shade,_INFONAME_,ShadeInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,RECEIVE_SHADOW,_VARYINGNAME_,ReceiveShadow,_MATRIXNAME_,receiveShadow,_INFONAME_,ReceiveShadowInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,SHADING_GRADE,_VARYINGNAME_,ShadingGrade,_MATRIXNAME_,shadingGrade,_INFONAME_,ShadingGradeInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,RIM,_VARYINGNAME_,Rim,_MATRIXNAME_,rim,_INFONAME_,RimInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,MATCAP,_VARYINGNAME_,MatCap,_MATRIXNAME_,matCap,_INFONAME_,MatCapInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,UV_ANIMATION_MASK,_VARYINGNAME_,UvAnimationMask,_MATRIXNAME_,uvAnimationMask,_INFONAME_,uvAnimationMaskInfos.x)\n\n#include<bumpVertex>\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n\n#ifdef VERTEXCOLOR\n    vColor = color;\n#elif defined(INSTANCESCOLOR) && INSTANCESCOLOR\n    vColor = instanceColor;\n#endif\n\n#include<pointCloudVertex>\n#include<logDepthVertex>\n\n#define CUSTOM_VERTEX_MAIN_END\n\n}\n",t.Effect.ShadersStore.mtoonFragmentShader="#include<__decl__mtoonFragment>\n\n#extension GL_OES_standard_derivatives : enable\n\n#include<prePassDeclaration>[SCENE_MRT_COUNT]\n#include<oitDeclaration>\n\n#define CUSTOM_FRAGMENT_BEGIN\n\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n\n// Constants\n#define RECIPROCAL_PI2 0.15915494\n#define PI_2 6.28318530718\n#define EPS_COL 0.00001\n\n// Input\nvarying vec3 vPositionW;\n\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)\nvarying vec4 vColor;\n#endif\n\n#include<mainUVVaryingDeclaration>[1..7]\n\n// Helper functions\n#include<helperFunctions>\n\n// Lights\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n\n// Samplers\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_SAMPLERNAME_,diffuse)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SHADE,_VARYINGNAME_,Shade,_SAMPLERNAME_,shade)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,RECEIVE_SHADOW,_VARYINGNAME_,ReceiveShadow,_SAMPLERNAME_,receiveShadow)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SHADING_GRADE,_VARYINGNAME_,ShadingGrade,_SAMPLERNAME_,shadingGrade)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,RIM,_VARYINGNAME_,Rim,_SAMPLERNAME_,rim)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,MATCAP,_VARYINGNAME_,MatCap,_SAMPLERNAME_,matCap)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,OUTLINE_WIDTH,_VARYINGNAME_,OutlineWidth,_SAMPLERNAME_,outlineWidth)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,UV_ANIMATION_MASK,_VARYINGNAME_,UvAnimationMask,_SAMPLERNAME_,uvAnimationMask)\n\n#include<mtoonFragmentFunctions>\n\n// # ifdef REFRACTION\n\n// # ifdef REFRACTIONMAP_3D\n// uniform samplerCube refractionCubeSampler;\n// # else\n// uniform sampler2D refraction2DSampler;\n// # endif\n\n// # endif\n\n// # if defined(SPECULARTERM)\n//     # include<samplerFragmentDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_SAMPLERNAME_,specular)\n// # endif\n\n// // Fresnel\n// # include<fresnelFunction>\n\n// // Reflection\n// # ifdef REFLECTION\n// # ifdef REFLECTIONMAP_3D\n// uniform samplerCube reflectionCubeSampler;\n// # else\n// uniform sampler2D reflection2DSampler;\n// # endif\n\n// # ifdef REFLECTIONMAP_SKYBOX\n// varying vec3 vPositionUVW;\n// # else\n// # if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\n// varying vec3 vDirectionW;\n// # endif\n\n// # endif\n\n// # include<reflectionFunction>\n\n// # endif\n\n#include<imageProcessingDeclaration>\n\n#include<imageProcessingFunctions>\n\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n\n#define CUSTOM_FRAGMENT_DEFINITIONS\n\nvoid main(void) {\n#ifdef MTOON_CLIP_IF_OUTLINE_IS_NONE\n    #ifdef MTOON_OUTLINE_WIDTH_WORLD\n    #elif defined(MTOON_OUTLINE_WIDTH_SCREEN)\n    #else\n        discard;\n    #endif\n#endif\n\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n\n#include<oitFragment>\n\n#include<clipPlaneFragment>\n\n    vec3 viewDirectionW = normalize(vEyePosition.xyz - vPositionW);\n\n    // Base color\n    vec4 baseColor = vec4(1., 1., 1., 1.);\n    vec3 diffuseColor = vec3(1., 1., 1.);\n\n    // Alpha\n    float alpha = 1.0;\n\n    // Bump\n#ifdef NORMAL\n    vec3 normalW = normalize(vNormalW);\n#else\n    vec3 normalW = normalize(-cross(dFdx(vPositionW), dFdy(vPositionW)));\n#endif\n\n#include<depthPrePass>\n\n    // Ambient color\n    vec3 baseAmbientColor = vec3(1., 1., 1.);\n    float glossiness = 0.;\n\n    // Lighting\n    vec3 diffuseBase = vec3(0., 0., 0.);\n    lightingInfo info;\n    float shadow = 1.;\n    vec3 lightDirection = vec3(0.0, 1.0, 0.0);\n    vec4 mtoonDiffuse = vec4(0.0, 0.0, 0.0, 1.0);\n\n    // MToon UV\n    // All textures will use diffuse(_MainTex) UV\n    vec2 mainUv = vec2(0.0);\n#ifdef DIFFUSE\n    mainUv += vDiffuseUV;\n#elif defined(MAINUV1)\n    mainUv += vMainUV1;\n#elif defined(MAINUV2)\n    mainUv += vMainUV2;\n#endif\n\n    // uv anim\n    float uvAnim = time.y;\n#ifdef UV_ANIMATION_MASK\n    uvAnim *= texture2D(uvAnimationMaskSampler, mainUv).r;\n#endif\n    // translate uv in bottom-left origin coordinates.\n    // uv is reversed\n    mainUv += vec2(-uvAnimationScrollX, -uvAnimationScrollY) * uvAnim;\n    // rotate uv counter-clockwise around (0.5, 0.5) in bottom-left origin coordinates.\n    float rotateRad = uvAnimationRotation * PI_2 * uvAnim;\n    vec2 rotatePivot = vec2(0.5, 0.5);\n    mainUv = mat2(cos(rotateRad), -sin(rotateRad), sin(rotateRad), cos(rotateRad)) * (mainUv - rotatePivot) + rotatePivot;\n\n#include<mtoonBumpFragment>\n\n#ifdef TWOSIDEDLIGHTING\n    normalW = gl_FrontFacing ? normalW : -normalW;\n#endif\n\n// include customized lightFragment\n#include<mtoonLightFragment>[0..maxSimultaneousLights]\n\n    vec3 finalDiffuse = clamp(diffuseBase, 0.0, 1.0) * baseColor.rgb;\n\n    // Composition\n    vec4 color = vec4(finalDiffuse, clamp(alpha, 0.0, 1.0));\n\n    color.rgb = max(color.rgb, 0.);\n#include<logDepthFragment>\n#include<fogFragment>\n\n// Apply image processing if relevant. As this applies in linear space,\n// We first move from gamma to linear.\n#ifdef IMAGEPROCESSINGPOSTPROCESS\n    color.rgb = toLinearSpace(color.rgb);\n#else\n    #ifdef IMAGEPROCESSING\n        // FIXME: support image processing\n        // color.rgb = toLinearSpace(color.rgb);\n        // color = applyImageProcessing(color);\n    #endif\n#endif\n\n    color.a *= visibility;\n\n#ifdef PREMULTIPLYALPHA\n    // Convert to associative (premultiplied) format if needed.\n    color.rgb *= color.a;\n#endif\n\n#ifdef PREPASS\n    float writeGeometryInfo = color.a > 0.4 ? 1.0 : 0.0;\n\n    gl_FragData[0] = color; // We can't split irradiance on std material\n\n    #ifdef PREPASS_POSITION\n    gl_FragData[PREPASS_POSITION_INDEX] = vec4(vPositionW, writeGeometryInfo);\n    #endif\n\n    #ifdef PREPASS_VELOCITY\n    vec2 a = (vCurrentPosition.xy / vCurrentPosition.w) * 0.5 + 0.5;\n    vec2 b = (vPreviousPosition.xy / vPreviousPosition.w) * 0.5 + 0.5;\n\n    vec2 velocity = abs(a - b);\n    velocity = vec2(pow(velocity.x, 1.0 / 3.0), pow(velocity.y, 1.0 / 3.0)) * sign(a - b) * 0.5 + 0.5;\n\n    gl_FragData[PREPASS_VELOCITY_INDEX] = vec4(velocity, 0.0, writeGeometryInfo);\n    #endif\n\n    #ifdef PREPASS_IRRADIANCE\n        gl_FragData[PREPASS_IRRADIANCE_INDEX] = vec4(0.0, 0.0, 0.0, writeGeometryInfo); //  We can't split irradiance on std material\n    #endif\n\n    #ifdef PREPASS_DEPTH\n        gl_FragData[PREPASS_DEPTH_INDEX] = vec4(vViewPos.z, 0.0, 0.0, writeGeometryInfo); // Linear depth\n    #endif\n\n    #ifdef PREPASS_NORMAL\n        gl_FragData[PREPASS_NORMAL_INDEX] = vec4((view * vec4(normalW, 0.0)).rgb, writeGeometryInfo); // Normal\n    #endif\n\n    #ifdef PREPASS_ALBEDO_SQRT\n        gl_FragData[PREPASS_ALBEDO_SQRT_INDEX] = vec4(0.0, 0.0, 0.0, writeGeometryInfo); // We can't split albedo on std material\n    #endif\n    #ifdef PREPASS_REFLECTIVITY\n        #if defined(SPECULAR)\n            gl_FragData[PREPASS_REFLECTIVITY_INDEX] = vec4(specularMapColor.rgb, specularMapColor.a * writeGeometryInfo);\n        #else\n            gl_FragData[PREPASS_REFLECTIVITY_INDEX] = vec4(0.0, 0.0, 0.0, writeGeometryInfo);\n        #endif\n    #endif\n#endif\n\n#if !defined(PREPASS) || defined(WEBGL2)\n    gl_FragColor = color;\n#endif\n\n#if ORDER_INDEPENDENT_TRANSPARENCY\n    if (fragDepth == nearestDepth) {\n        frontColor.rgb += color.rgb * color.a * alphaMultiplier;\n        frontColor.a = 1.0 - alphaMultiplier * (1.0 - color.a);\n    } else {\n        backColor += color;\n    }\n#endif\n\n#define CUSTOM_FRAGMENT_MAIN_END\n\n}\n"),this.inspectableCustomProperties=this.inspectableCustomProperties||[],this.inspectableCustomProperties.push({label:"DiffuseColor",propertyName:"diffuseColor",type:t.InspectableType.Color3},{label:"AmbientColor",propertyName:"ambientColor",type:t.InspectableType.Color3},{label:"EmissiveColor",propertyName:"emissiveColor",type:t.InspectableType.Color3},{label:"ShadeColor",propertyName:"shadeColor",type:t.InspectableType.Color3},{label:"RimColor",propertyName:"rimColor",type:t.InspectableType.Color3},{label:"OutlineColor",propertyName:"outlineColor",type:t.InspectableType.Color3},{label:"ReceiveShadowRate",propertyName:"receiveShadowRate",type:t.InspectableType.Slider,min:0,max:1,step:.01},{label:"ShadingGradeRate",propertyName:"shadingGradeRate",type:t.InspectableType.Slider,min:0,max:1,step:.01},{label:"ShadeShift",propertyName:"shadeShift",type:t.InspectableType.Slider,min:-1,max:1,step:.01},{label:"ShadeToony",propertyName:"shadeToony",type:t.InspectableType.Slider,min:0,max:1,step:.01},{label:"LightColorAttenuation",propertyName:"lightColorAttenuation",type:t.InspectableType.Slider,min:0,max:1,step:.01},{label:"IndirectLightIntensity",propertyName:"indirectLightIntensity",type:t.InspectableType.Slider,min:0,max:1,step:.01},{label:"RimLightingMix",propertyName:"rimLightingMix",type:t.InspectableType.Slider,min:0,max:1,step:.01},{label:"RimFresnelPower",propertyName:"rimFresnelPower",type:t.InspectableType.Slider,min:.01,max:100,step:4},{label:"RimLift",propertyName:"rimLift",type:t.InspectableType.Slider,min:0,max:1,step:.01},{label:"OutlineWidth",propertyName:"outlineWidth",type:t.InspectableType.Slider,min:.01,max:1,step:.01},{label:"OutlineScaledMaxDistance",propertyName:"outlineScaledMaxDistance",type:t.InspectableType.Slider,min:1,max:10,step:.01},{label:"OutlineLightingMix",propertyName:"outlineLightingMix",type:t.InspectableType.Slider,min:0,max:1,step:.01},{label:"DebugMode",propertyName:"debugMode",type:t.InspectableType.Slider,min:0,max:2,step:1},{label:"OutlineWidthMode",propertyName:"outlineWidthMode",type:t.InspectableType.Slider,min:0,max:2,step:1},{label:"OutlineColorMode",propertyName:"outlineColorMode",type:t.InspectableType.Slider,min:0,max:1,step:1},{label:"CullMode",propertyName:"cullMode",type:t.InspectableType.Slider,min:0,max:2,step:1},{label:"OutlineCullMode",propertyName:"outlineCullMode",type:t.InspectableType.Slider,min:0,max:2,step:1},{label:"AlphaCutOff",propertyName:"alphaCutOff",type:t.InspectableType.Slider,min:0,max:1,step:.01},{label:"UV Animation Scroll X",propertyName:"uvAnimationScrollX",type:t.InspectableType.Slider,min:-1,max:1,step:.1},{label:"UV Animation Scroll Y",propertyName:"uvAnimationScrollY",type:t.InspectableType.Slider,min:-1,max:1,step:.1},{label:"UV Animation Rotation",propertyName:"uvAnimationRotation",type:t.InspectableType.Slider,min:-.5,max:.5,step:.01})}get appendedTextures(){return[this._diffuseTexture,this._emissiveTexture,this._bumpTexture,this._shadeTexture,this._receiveShadowTexture,this._shadingGradeTexture,this._rimTexture,this._matCapTexture,this._outlineWidthTexture,this._uvAnimationMaskTexture]}get appendedActiveTextures(){return this.appendedTextures.filter((e=>null!==e))}get imageProcessingConfiguration(){return this._imageProcessingConfiguration}set imageProcessingConfiguration(e){this._attachImageProcessingConfiguration(e),this._markAllSubMeshesAsTexturesDirty()}_attachImageProcessingConfiguration(e){e!==this._imageProcessingConfiguration&&(this._imageProcessingConfiguration&&this._imageProcessingObserver&&this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver),this._imageProcessingConfiguration=e||this.getScene().imageProcessingConfiguration,this._imageProcessingConfiguration&&(this._imageProcessingObserver=this._imageProcessingConfiguration.onUpdateParameters.add((()=>{this._markAllSubMeshesAsImageProcessingDirty()}))))}get isPrePassCapable(){return!1}get cameraColorCurvesEnabled(){return this.imageProcessingConfiguration.colorCurvesEnabled}set cameraColorCurvesEnabled(e){this.imageProcessingConfiguration.colorCurvesEnabled=e}get cameraColorGradingEnabled(){return this.imageProcessingConfiguration.colorGradingEnabled}set cameraColorGradingEnabled(e){this.imageProcessingConfiguration.colorGradingEnabled=e}get cameraToneMappingEnabled(){return this._imageProcessingConfiguration.toneMappingEnabled}set cameraToneMappingEnabled(e){this._imageProcessingConfiguration.toneMappingEnabled=e}get cameraExposure(){return this._imageProcessingConfiguration.exposure}set cameraExposure(e){this._imageProcessingConfiguration.exposure=e}get cameraContrast(){return this._imageProcessingConfiguration.contrast}set cameraContrast(e){this._imageProcessingConfiguration.contrast=e}get cameraColorGradingTexture(){return this._imageProcessingConfiguration.colorGradingTexture}set cameraColorGradingTexture(e){this._imageProcessingConfiguration.colorGradingTexture=e}get cameraColorCurves(){return this._imageProcessingConfiguration.colorCurves}set cameraColorCurves(e){this._imageProcessingConfiguration.colorCurves=e}get canRenderToMRT(){return!0}get bumpScale(){return this._bumpScale}set bumpScale(e){this._bumpScale=e}get receiveShadowRate(){return this._receiveShadowRate}set receiveShadowRate(e){this._receiveShadowRate=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get shadingGradeRate(){return this._shadingGradeRate}set shadingGradeRate(e){this._shadingGradeRate=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get shadeShift(){return this._shadeShift}set shadeShift(e){this._shadeShift=Math.max(-1,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get shadeToony(){return this._shadeToony}set shadeToony(e){this._shadeToony=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get lightColorAttenuation(){return this._lightColorAttenuation}set lightColorAttenuation(e){this._lightColorAttenuation=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get indirectLightIntensity(){return this._indirectLightIntensity}set indirectLightIntensity(e){this._indirectLightIntensity=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get rimLightingMix(){return this._rimLightingMix}set rimLightingMix(e){this._rimLightingMix=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get rimFresnelPower(){return this._rimFresnelPower}set rimFresnelPower(e){this._rimFresnelPower=Math.max(0,Math.min(100,e)),this._markAllSubMeshesAsLightsDirty()}get rimLift(){return this._rimLift}set rimLift(e){this._rimLift=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get outlineWidth(){return this._outlineWidth}set outlineWidth(e){this._outlineWidth=Math.max(.01,Math.min(1,e)),this._markAllSubMeshesAsAttributesDirty()}get outlineScaledMaxDistance(){return this._outlineScaledMaxDistance}set outlineScaledMaxDistance(e){this._outlineScaledMaxDistance=Math.max(1,Math.min(10,e)),this._markAllSubMeshesAsAttributesDirty()}get outlineLightingMix(){return this._outlineLightingMix}set outlineLightingMix(e){this._outlineLightingMix=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsAttributesDirty()}get uvAnimationScrollX(){return this._uvAnimationScrollX}set uvAnimationScrollX(e){this._uvAnimationScrollX=e,this._markAllSubMeshesAsMiscDirty()}get uvAnimationScrollY(){return this._uvAnimationScrollY}set uvAnimationScrollY(e){this._uvAnimationScrollY=e,this._markAllSubMeshesAsMiscDirty()}get uvAnimationRotation(){return this._uvAnimationRotation}set uvAnimationRotation(e){this._uvAnimationRotation=e,this._markAllSubMeshesAsMiscDirty()}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest=e,e?this.alphaBlend?this._transparencyMode=t.Material.MATERIAL_ALPHATESTANDBLEND:this._transparencyMode=t.Material.MATERIAL_ALPHATEST:this._transparencyMode=t.Material.MATERIAL_OPAQUE,this._markAllSubMeshesAsMiscDirty()}get alphaBlend(){return this._alphaBlend}set alphaBlend(e){this._alphaBlend=e,e?(this.backFaceCulling=!0,this.alphaTest?this._transparencyMode=t.Material.MATERIAL_ALPHATESTANDBLEND:this._transparencyMode=t.Material.MATERIAL_ALPHABLEND):this._transparencyMode=t.Material.MATERIAL_OPAQUE,this._markAllSubMeshesAsMiscDirty()}get outlineWidthMode(){return this._outlineWidthMode}set outlineWidthMode(e){this._outlineWidthMode=e,e===d.None||this.outlineRenderer||(this.outlineRenderer=new o(this.getScene(),this)),this._markAllSubMeshesAsMiscDirty()}enableOutlineRender(){this.isOutline=1}disaableOutlineRender(){this.isOutline=0}get cullMode(){return this._cullMode}set cullMode(e){switch(this._cullMode=e,this._cullMode){case h.Off:this.backFaceCulling=!1,this.sideOrientation=t.Material.ClockWiseSideOrientation,this.twoSidedLighting=!1;break;case h.Front:this.backFaceCulling=!0,this.sideOrientation=t.Material.CounterClockWiseSideOrientation,this.twoSidedLighting=!0;break;case h.Back:this.backFaceCulling=!0,this.sideOrientation=t.Material.ClockWiseSideOrientation,this.twoSidedLighting=!1}this._markAllSubMeshesAsMiscDirty()}applyOutlineCullMode(){this.storedCullMode=this.cullMode,this.cullMode=this._outlineCullMode}restoreOutlineCullMode(){this.cullMode=this.storedCullMode}getOutlineRendererName(){return this.outlineRenderer?this.outlineRenderer.name:""}get hasRenderTargetTextures(){return!1}getClassName(){return"MToonMaterial"}get useLogarithmicDepth(){return this._useLogarithmicDepth}set useLogarithmicDepth(e){const i=e&&this.getScene().getEngine().getCaps().fragmentDepthSupported;this._useLogarithmicDepth!==i&&(this._useLogarithmicDepth=i,this._markAllSubMeshesAsMiscDirty())}needAlphaBlending(){return!this._disableAlphaBlending&&(this.alpha<1||this._shouldUseAlphaFromDiffuseTexture())}needAlphaTesting(){return!!this._forceAlphaTest||!!this._alphaTest||this._hasAlphaChannel()&&(null==this._transparencyMode||this._transparencyMode===t.Material.MATERIAL_ALPHATEST)}_shouldUseAlphaFromDiffuseTexture(){return null!=this._diffuseTexture&&this._diffuseTexture.hasAlpha&&this._useAlphaFromDiffuseTexture&&this._transparencyMode!==t.Material.MATERIAL_OPAQUE}_hasAlphaChannel(){return null!==this._diffuseTexture&&this._diffuseTexture.hasAlpha}getAlphaTestTexture(){return this._diffuseTexture}isReadyForSubMesh(e,i,n=!1){if(this._uniformBufferLayoutBuilt||this.buildUniformLayout(),i.effect&&this.isFrozen&&i.effect._wasPreviouslyReady&&i.effect._wasPreviouslyUsingInstances===n)return!0;i.materialDefines||(this._callbackPluginEventGeneric(t.MaterialPluginEvent.GetDefineNames,this._eventInfo),i.materialDefines=new a);const o=this.getScene(),s=i.materialDefines;if(this._isReadyForSubMesh(i))return!0;const l=o.getEngine();s._needNormals=t.MaterialHelper.PrepareDefinesForLights(o,e,s,this.specularSupported,this._maxSimultaneousLights,this._disableLighting),this.outlineWidthMode!==d.None&&(s._needNormals=!0),this.applyDefines(s),t.MaterialHelper.PrepareDefinesForMultiview(o,s);const h=this.needAlphaBlendingForMesh(e)&&o.useOrderIndependentTransparency;if(t.MaterialHelper.PrepareDefinesForOIT(o,s,h),s._areTexturesDirty){this._eventInfo.hasRenderTargetTextures=!1,this._callbackPluginEventHasRenderTargetTextures(this._eventInfo),this._cacheHasRenderTargetTextures=this._eventInfo.hasRenderTargetTextures,s._needUVs=!1;for(let e=1;e<=t.Constants.MAX_SUPPORTED_UV_SETS;++e)s["MAINUV"+e]=!1;if(o.texturesEnabled){if(!(this.isReadyForTexture(this._diffuseTexture,s,"DIFFUSE")&&this.isReadyForTexture(this._emissiveTexture,s,"EMISSIVE")&&this.isReadyForTexture(this._shadeTexture,s,"SHADE")&&this.isReadyForTexture(this._receiveShadowTexture,s,"RECEIVE_SHADOW")&&this.isReadyForTexture(this._shadingGradeTexture,s,"SHADING_GRADE")&&this.isReadyForTexture(this._rimTexture,s,"RIM")&&this.isReadyForTexture(this._matCapTexture,s,"MATCAP")&&this.isReadyForTexture(this._outlineWidthTexture,s,"OUTLINE_WIDTH")&&this.isReadyForTexture(this._uvAnimationMaskTexture,s,"UV_ANIMATION_MASK")))return!1;if(o.getEngine().getCaps().standardDerivatives&&this._bumpTexture){if(!this._bumpTexture.isReady())return!1;t.MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture,s,"BUMP"),s.PARALLAX=this.useParallax,s.PARALLAXOCCLUSION=this.useParallaxOcclusion,s.OBJECTSPACE_NORMALMAP=this.useObjectSpaceNormalMap}else s.BUMP=!1,s.PARALLAX=!1,s.PARALLAXOCCLUSION=!1;s.TWOSIDEDLIGHTING=!this._backFaceCulling&&this._twoSidedLighting}else s.DIFFUSE=!1,s.EMISSIVE=!1,s.SHADE=!1,s.RECEIVE_SHADOW=!1,s.SHADING_GRADE=!1,s.RIM=!1,s.MATCAP=!1,s.OUTLINE_WIDTH=!1,s.BUMP=!1,s.UV_ANIMATION_MASK=!1;s.ALPHAFROMDIFFUSE=this._shouldUseAlphaFromDiffuseTexture(),s.PREMULTIPLYALPHA=this.alphaMode===t.Constants.ALPHA_PREMULTIPLIED||this.alphaMode===t.Constants.ALPHA_PREMULTIPLIED_PORTERDUFF,s.ALPHATEST_AFTERALLALPHACOMPUTATIONS=null!==this.transparencyMode,s.ALPHABLEND=null===this.transparencyMode||this.needAlphaBlendingForMesh(e)}if(this._eventInfo.isReadyForSubMesh=!0,this._eventInfo.defines=s,this._callbackPluginEventIsReadyForSubMesh(this._eventInfo),!this._eventInfo.isReadyForSubMesh)return!1;if(s._areImageProcessingDirty&&this._imageProcessingConfiguration){if(!this._imageProcessingConfiguration.isReady())return!1;this._imageProcessingConfiguration.prepareDefines(s)}if(t.MaterialHelper.PrepareDefinesForMisc(e,o,this._useLogarithmicDepth,this.pointsCloud,this.fogEnabled,this._shouldTurnAlphaTestOn(e)||this._forceAlphaTest,s),t.MaterialHelper.PrepareDefinesForFrameBoundValues(o,l,s,n,null,i.getRenderingMesh().hasThinInstances),this._eventInfo.defines=s,this._eventInfo.mesh=e,this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo),t.MaterialHelper.PrepareDefinesForAttributes(e,s,this.useVertexColor,this.useBones,this.useMorphTargets,this.useVertexAlpha,this.useBakedVertexAnimation),this._callbackPluginEventPrepareDefines(this._eventInfo),s.isDirty){const n=s._areLightsDisposed;s.markAsProcessed();const a=new t.EffectFallbacks;s.BUMP&&a.addFallback(0,"BUMP"),s.PARALLAX&&a.addFallback(1,"PARALLAX"),s.PARALLAXOCCLUSION&&a.addFallback(0,"PARALLAXOCCLUSION"),s.FOG&&a.addFallback(1,"FOG"),s.POINTSIZE&&a.addFallback(0,"POINTSIZE"),s.LOGARITHMICDEPTH&&a.addFallback(0,"LOGARITHMICDEPTH"),t.MaterialHelper.HandleFallbacksForShadows(s,a,this._maxSimultaneousLights),s.MULTIVIEW&&a.addFallback(0,"MULTIVIEW");const d=[t.VertexBuffer.PositionKind];s.NORMAL&&d.push(t.VertexBuffer.NormalKind),s.TANGENT&&d.push(t.VertexBuffer.TangentKind);for(let e=1;e<=t.Constants.MAX_SUPPORTED_UV_SETS;++e)s["UV"+e]&&d.push(`uv${1===e?"":e}`);s.INSTANCESCOLOR&&d.push(t.VertexBuffer.ColorInstanceKind),t.MaterialHelper.PrepareAttributesForBones(d,e,s,a),t.MaterialHelper.PrepareAttributesForInstances(d,s),t.MaterialHelper.PrepareAttributesForMorphTargets(d,e,s),t.MaterialHelper.PrepareAttributesForBakedVertexAnimation(d,e,s);const h="mtoon",f=["world","view","viewProjection","vEyePosition","vLightsType","vAmbientColor","visibility","vFogInfos","vFogColor","pointSize","mBones","vClipPlane","vClipPlane2","vClipPlane3","vClipPlane4","vClipPlane5","vClipPlane6","logarithmicDepthConstant","vTangentSpaceParams","alphaCutOff","boneTextureWidth","morphTargetTextureInfo","morphTargetTextureIndices","vDiffuseColor","vDiffuseInfos","diffuseMatrix","vEmissiveColor","vEmissiveInfos","emissiveMatrix","vBumpInfos","bumpMatrix","vShadeColor","vShadeInfos","shadeMatrix","vReceiveShadowInfos","receiveShadowMatrix","vShadingGradeInfos","shadingGradeMatrix","vRimColor","vRimInfos","RimMatrix","vMatCapInfos","MatCapMatrix","vOutlineColor","vOutlineWidthInfos","outlineWidthMatrix","aspect","isOutline","shadingGradeRate","receiveShadowRate","shadeShift","shadeToony","rimLightingMix","rimFresnelPower","rimLift","lightColorAttenuation","indirectLightIntensity","outlineWidth","outlineScaledMaxDistance","outlineLightingMix","uvAnimationScrollX","uvAnimationScrollY","uvAnimationRotation","vEyeUp","time","projection"],u=["diffuseSampler","ambientSampler","emissiveSampler","bumpSampler","boneSampler","morphTargets","oitDepthSampler","oitFrontColorSampler","shadeSampler","receiveShadowSampler","shadingGradeSampler","rimSampler","matCapSampler","outlineWidthSampler","uvAnimationMaskSampler"],m=["Material","Scene","Mesh"];this._eventInfo.fallbacks=a,this._eventInfo.fallbackRank=0,this._eventInfo.defines=s,this._eventInfo.uniforms=f,this._eventInfo.attributes=d,this._eventInfo.samplers=u,this._eventInfo.uniformBuffersNames=m,this._eventInfo.customCode=void 0,this._eventInfo.mesh=e,this._callbackPluginEventGeneric(t.MaterialPluginEvent.PrepareEffect,this._eventInfo),t.ImageProcessingConfiguration&&(t.ImageProcessingConfiguration.PrepareUniforms(f,s),t.ImageProcessingConfiguration.PrepareSamplers(u,s)),t.MaterialHelper.PrepareUniformsAndSamplersList({uniformsNames:f,uniformBuffersNames:m,samplers:u,defines:s,maxSimultaneousLights:this._maxSimultaneousLights});const c={},p=s.toString(),g=i.effect;let _=o.getEngine().createEffect(h,{attributes:d,uniformsNames:f,uniformBuffersNames:m,samplers:u,defines:p,fallbacks:a,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousLights:this._maxSimultaneousLights,maxSimultaneousMorphTargets:s.NUM_MORPH_INFLUENCERS},processFinalCode:c.processFinalCode,processCodeAfterIncludes:this._eventInfo.customCode,multiTarget:s.PREPASS},l);if(_)if(this._onEffectCreatedObservable&&(r.effect=_,r.subMesh=i,this._onEffectCreatedObservable.notifyObservers(r)),this.allowShaderHotSwapping&&g&&!_.isReady()){if(_=g,s.markAsUnprocessed(),n)return s._areLightsDisposed=!0,!1}else o.resetCachedMaterial(),i.setEffect(_,s,this._materialContext)}return!(!i.effect||!i.effect.isReady()||(s._renderId=o.getRenderId(),i.effect._wasPreviouslyReady=!0,i.effect._wasPreviouslyUsingInstances=n,0))}buildUniformLayout(){const e=this._uniformBuffer;e.addUniform("vDiffuseColor",4),e.addUniform("vDiffuseInfos",2),e.addUniform("diffuseMatrix",16),e.addUniform("vEmissiveColor",3),e.addUniform("vEmissiveInfos",2),e.addUniform("emissiveMatrix",16),e.addUniform("vBumpInfos",3),e.addUniform("bumpMatrix",16),e.addUniform("vShadeColor",3),e.addUniform("vShadeInfos",2),e.addUniform("shadeMatrix",16),e.addUniform("vReceiveShadowInfos",2),e.addUniform("receiveShadowMatrix",16),e.addUniform("vShadingGradeInfos",2),e.addUniform("shadingGradeMatrix",16),e.addUniform("vRimColor",3),e.addUniform("vRimInfos",2),e.addUniform("rimMatrix",16),e.addUniform("vMatCapInfos",2),e.addUniform("matCapMatrix",16),e.addUniform("vOutlineColor",3),e.addUniform("vOutlineWidthInfos",2),e.addUniform("outlineWidthMatrix",16),e.addUniform("vUvAnimationMaskInfos",2),e.addUniform("uvAnimationMaskMatrix",16),e.addUniform("vTangentSpaceParams",2),e.addUniform("pointSize",1),e.addUniform("shadingGradeRate",1),e.addUniform("receiveShadowRate",1),e.addUniform("shadeShift",1),e.addUniform("shadeToony",1),e.addUniform("lightColorAttenuation",1),e.addUniform("indirectLightIntensity",1),e.addUniform("rimLightingMix",1),e.addUniform("rimFresnelPower",1),e.addUniform("rimLift",1),e.addUniform("outlineWidth",1),e.addUniform("outlineScaledMaxDistance",1),e.addUniform("outlineLightingMix",1),e.addUniform("uvAnimationScrollX",1),e.addUniform("uvAnimationScrollY",1),e.addUniform("uvAnimationRotation",1),e.addUniform("vEyeUp",3),e.addUniform("alphaCutOff",1),e.addUniform("vAmbientColor",3),e.addUniform("aspect",1),e.addUniform("isOutline",1),e.addUniform("time",4),e.addUniform("visibility",1),super.buildUniformLayout()}bindForSubMesh(e,i,n){var o;const a=this.getScene(),r=n.materialDefines,s=n.effect;if(!r||!s)return;this._activeEffect=s,i.getMeshUniformBuffer().bindToEffect(s,"Mesh"),i.transferToEffect(e),this._uniformBuffer.bindToEffect(s,"Material"),this._eventInfo.subMesh=n,this._callbackPluginEventHardBindForSubMesh(this._eventInfo),r.OBJECTSPACE_NORMALMAP&&(e.toNormalMatrix(this._normalMatrix),this.bindOnlyNormalMatrix(this._normalMatrix));const l=this._mustRebind(a,s,i.visibility);t.MaterialHelper.BindBonesParameters(i,s);const d=this._uniformBuffer;if(l){this.bindViewProjection(s),d.useUbo&&this.isFrozen&&d.isSync||(a.texturesEnabled&&(this.bindTexture(this._diffuseTexture,d,s,"diffuse","vDiffuseInfos"),this.bindTexture(this._emissiveTexture,d,s,"emissive","vEmissiveInfos"),this._bumpTexture&&a.getEngine().getCaps().standardDerivatives&&(d.updateFloat3("vBumpInfos",this._bumpTexture.coordinatesIndex,1/this._bumpTexture.level,this._bumpScale),t.MaterialHelper.BindTextureMatrix(this._bumpTexture,d,"bump"),s.setTexture("bumpSampler",this._bumpTexture),a._mirroredCameraPosition?d.updateFloat2("vTangentSpaceParams",this._invertNormalMapX?1:-1,this._invertNormalMapY?1:-1):d.updateFloat2("vTangentSpaceParams",this._invertNormalMapX?-1:1,this._invertNormalMapY?-1:1)),this.bindTexture(this._shadeTexture,d,s,"shade","vShadeInfos"),this.bindTexture(this._receiveShadowTexture,d,s,"receiveShadow","vReceiveShadowInfos"),this.bindTexture(this._shadingGradeTexture,d,s,"shadingGrade","vShadingGradeInfos"),this.bindTexture(this._rimTexture,d,s,"rim","vRimInfos"),this.bindTexture(this._matCapTexture,d,s,"matCap","vMatCapInfos"),this.bindTexture(this._outlineWidthTexture,d,s,"outlineWidth","vOutlineWidthInfos"),this.bindTexture(this._uvAnimationMaskTexture,d,s,"uvAnimationMask","vUvAnimationMaskInfos"),this._hasAlphaChannel()&&d.updateFloat("alphaCutOff",this.alphaCutOff)),this.pointsCloud&&d.updateFloat("pointSize",this.pointSize),d.updateFloat("receiveShadowRate",this._receiveShadowRate),d.updateFloat("shadingGradeRate",this._shadingGradeRate),d.updateFloat("shadeShift",this._shadeShift),d.updateFloat("shadeToony",this._shadeToony),d.updateFloat("lightColorAttenuation",this._lightColorAttenuation),d.updateFloat("indirectLightIntensity",this._indirectLightIntensity),d.updateFloat("rimLightingMix",this._rimLightingMix),d.updateFloat("rimFresnelPower",this._rimFresnelPower),d.updateFloat("rimLift",this._rimLift),d.updateFloat("outlineWidth",this._outlineWidth),d.updateFloat("outlineScaledMaxDistance",this._outlineScaledMaxDistance),d.updateFloat("outlineLightingMix",this._outlineLightingMix),d.updateFloat("uvAnimationScrollX",this._uvAnimationScrollX),d.updateFloat("uvAnimationScrollY",this._uvAnimationScrollY),d.updateFloat("uvAnimationRotation",this._uvAnimationRotation),a.ambientColor.multiplyToRef(this.ambientColor,this._globalAmbientColor),d.updateColor3("vAmbientColor",this._globalAmbientColor),d.updateColor4("vDiffuseColor",this.diffuseColor,this.alpha),d.updateColor3("vEmissiveColor",this.emissiveColor),d.updateColor3("vShadeColor",this.shadeColor),d.updateColor3("vRimColor",this.rimColor),d.updateColor4("vOutlineColor",this.outlineColor,1),d.updateVector3("vEyeUp",a.activeCamera.upVector));const e=a;e.useOrderIndependentTransparency&&this.needAlphaBlendingForMesh(i)&&e.depthPeelingRenderer&&e.depthPeelingRenderer.bind(s),this._eventInfo.subMesh=n,this._callbackPluginEventBindForSubMesh(this._eventInfo),t.MaterialHelper.BindClipPlane(s,a),this.bindEyePosition(s)}else a.getEngine()._features.needToAlwaysBindUniformBuffers&&(this._needToBindSceneUbo=!0);if(l||!this.isFrozen){a.lightsEnabled&&!this._disableLighting&&t.MaterialHelper.BindLights(a,i,s,r,this._maxSimultaneousLights),(a.fogEnabled&&i.applyFog&&a.fogMode!==t.Scene.FOGMODE_NONE||i.receiveShadows)&&this.bindView(s),t.MaterialHelper.BindFogParameters(a,i,s),r.NUM_MORPH_INFLUENCERS&&t.MaterialHelper.BindMorphTargetParameters(i,s),r.BAKED_VERTEX_ANIMATION_TEXTURE&&(null===(o=i.bakedVertexAnimationManager)||void 0===o||o.bind(s,r.INSTANCES)),this.useLogarithmicDepth&&t.MaterialHelper.BindLogDepth(r,s,a),this._imageProcessingConfiguration&&!this._imageProcessingConfiguration.applyByPostProcess&&this._imageProcessingConfiguration.bind(this._activeEffect),d.updateFloat("aspect",a.getEngine().getAspectRatio(a.activeCamera)),d.updateFloat("isOutline",this.isOutline);const e=window.performance.now()/1e3;d.updateVector4("time",new t.Vector4(e/20,e,2*e,3*e))}this._afterBind(i,this._activeEffect),d.update()}getAnimatables(){const e=super.getAnimatables();for(const i of this.appendedActiveTextures)i.animations&&i.animations.length>0&&e.push(i);return e}getActiveTextures(){return super.getActiveTextures().concat(this.appendedActiveTextures)}hasTexture(e){if(super.hasTexture(e))return!0;for(const i of this.appendedActiveTextures)if(i===e)return!0;return!1}dispose(e,i){if(delete this.outlineRenderer,i)for(const e of this.appendedActiveTextures)e.dispose();this._imageProcessingConfiguration&&this._imageProcessingObserver&&this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver),super.dispose(e,i)}clone(e){const i=t.SerializationHelper.Clone((()=>new f(e,this.getScene())),this);return i.name=e,i.id=e,this.stencil.copyTo(i.stencil),i}static Parse(e,i,n){const o=t.SerializationHelper.Parse((()=>new f(e.name,i)),e,i,n);return e.stencil&&o.stencil.parse(e.stencil,i,n),o}bindTexture(e,i,n,o,a){e&&(this._uniformBuffer.updateFloat2(a,e.coordinatesIndex,e.level),t.MaterialHelper.BindTextureMatrix(e,i,o),n.setTexture(`${o}Sampler`,e))}isReadyForTexture(e,i,n){return e?!!e.isReadyOrNotBlocking()&&(t.MaterialHelper.PrepareDefinesForMergedUV(e,i,n),!0):(i[n]=!1,!0)}applyDefines(e){switch(this._debugMode){case s.Normal:!0!==e.MTOON_DEBUG_NORMAL&&(e.MTOON_DEBUG_NORMAL=!0,e.MTOON_DEBUG_LITSHADERATE=!1,e.markAsUnprocessed());break;case s.LitShadeRate:!0!==e.MTOON_DEBUG_LITSHADERATE&&(e.MTOON_DEBUG_NORMAL=!1,e.MTOON_DEBUG_LITSHADERATE=!0,e.markAsUnprocessed());break;case s.None:!0===e.MTOON_DEBUG_NORMAL&&(e.MTOON_DEBUG_NORMAL=!1,e.markAsUnprocessed()),!0===e.MTOON_DEBUG_LITSHADERATE&&(e.MTOON_DEBUG_LITSHADERATE=!1,e.markAsUnprocessed())}switch(this.outlineWidthMode){case d.WorldCorrdinates:!0!==e.MTOON_OUTLINE_WIDTH_WORLD&&(e.MTOON_OUTLINE_WIDTH_WORLD=!0,e.MTOON_OUTLINE_WIDTH_SCREEN=!1,e.markAsUnprocessed());break;case d.ScreenCoordinates:!0!==e.MTOON_OUTLINE_WIDTH_SCREEN&&(e.MTOON_OUTLINE_WIDTH_WORLD=!1,e.MTOON_OUTLINE_WIDTH_SCREEN=!0,e.markAsUnprocessed());break;case d.None:!1===e.MTOON_OUTLINE_WIDTH_SCREEN&&!1===e.MTOON_OUTLINE_WIDTH_WORLD||(e.MTOON_OUTLINE_WIDTH_SCREEN=!1,e.MTOON_OUTLINE_WIDTH_WORLD=!1,e.markAsUnprocessed())}switch(this.outlineColorMode){case l.FixedColor:!0!==e.MTOON_OUTLINE_COLOR_FIXED&&(e.MTOON_OUTLINE_COLOR_FIXED=!0,e.MTOON_OUTLINE_COLOR_MIXED=!1,e.markAsUnprocessed());break;case l.MixedLighting:!0!==e.MTOON_OUTLINE_COLOR_MIXED&&(e.MTOON_OUTLINE_COLOR_FIXED=!1,e.MTOON_OUTLINE_COLOR_MIXED=!0,e.markAsUnprocessed())}}}n([(0,t.serializeAsTexture)("diffuseTexture")],f.prototype,"_diffuseTexture",void 0),n([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesAndMiscDirty")],f.prototype,"diffuseTexture",void 0),n([(0,t.serializeAsTexture)("emissiveTexture")],f.prototype,"_emissiveTexture",void 0),n([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],f.prototype,"emissiveTexture",void 0),n([(0,t.serializeAsTexture)("bumpTexture")],f.prototype,"_bumpTexture",void 0),n([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],f.prototype,"bumpTexture",void 0),n([(0,t.serializeAsTexture)("shadeTexture")],f.prototype,"_shadeTexture",void 0),n([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],f.prototype,"shadeTexture",void 0),n([(0,t.serializeAsTexture)("receiveShadowTexture")],f.prototype,"_receiveShadowTexture",void 0),n([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],f.prototype,"receiveShadowTexture",void 0),n([(0,t.serializeAsTexture)("shadingGradeTexture")],f.prototype,"_shadingGradeTexture",void 0),n([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],f.prototype,"shadingGradeTexture",void 0),n([(0,t.serializeAsTexture)("rimTexture")],f.prototype,"_rimTexture",void 0),n([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],f.prototype,"rimTexture",void 0),n([(0,t.serializeAsTexture)("matCapTexture")],f.prototype,"_matCapTexture",void 0),n([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],f.prototype,"matCapTexture",void 0),n([(0,t.serializeAsTexture)("outlineWidthTexture")],f.prototype,"_outlineWidthTexture",void 0),n([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],f.prototype,"outlineWidthTexture",void 0),n([(0,t.serializeAsTexture)("outlineWidthTexture")],f.prototype,"_uvAnimationMaskTexture",void 0),n([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],f.prototype,"uvAnimationMaskTexture",void 0),n([(0,t.serializeAsColor3)("diffuse")],f.prototype,"diffuseColor",void 0),n([(0,t.serialize)("ambient")],f.prototype,"ambientColor",void 0),n([(0,t.serialize)("emissive")],f.prototype,"emissiveColor",void 0),n([(0,t.serialize)("shade")],f.prototype,"shadeColor",void 0),n([(0,t.serialize)("rim")],f.prototype,"rimColor",void 0),n([(0,t.serialize)("outline")],f.prototype,"outlineColor",void 0),n([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],f.prototype,"useEmissiveAsIllumination",void 0),n([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],f.prototype,"linkEmissiveWithDiffuse",void 0),n([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],f.prototype,"useReflectionOverAlpha",void 0),n([(0,t.serialize)("disableLighting")],f.prototype,"_disableLighting",void 0),n([(0,t.expandToProperty)("_markAllSubMeshesAsLightsDirty")],f.prototype,"disableLighting",void 0),n([(0,t.serialize)()],f.prototype,"alphaCutOff",void 0),n([(0,t.serialize)("useAlphaFromDiffuseTexture")],f.prototype,"_useAlphaFromDiffuseTexture",void 0),n([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesAndMiscDirty")],f.prototype,"useAlphaFromDiffuseTexture",void 0),n([(0,t.serialize)("maxSimultaneousLights")],f.prototype,"_maxSimultaneousLights",void 0),n([(0,t.expandToProperty)("_markAllSubMeshesAsLightsDirty")],f.prototype,"maxSimultaneousLights",void 0),n([(0,t.serialize)("invertNormalMapX")],f.prototype,"_invertNormalMapX",void 0),n([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],f.prototype,"invertNormalMapX",void 0),n([(0,t.serialize)("invertNormalMapY")],f.prototype,"_invertNormalMapY",void 0),n([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],f.prototype,"invertNormalMapY",void 0),n([(0,t.serialize)("twoSidedLighting")],f.prototype,"_twoSidedLighting",void 0),n([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],f.prototype,"twoSidedLighting",void 0),n([(0,t.serialize)()],f.prototype,"bumpScale",null),n([(0,t.serialize)()],f.prototype,"receiveShadowRate",null),n([(0,t.serialize)()],f.prototype,"shadingGradeRate",null),n([(0,t.serialize)()],f.prototype,"shadeShift",null),n([(0,t.serialize)()],f.prototype,"shadeToony",null),n([(0,t.serialize)()],f.prototype,"lightColorAttenuation",null),n([(0,t.serialize)()],f.prototype,"indirectLightIntensity",null),n([(0,t.serialize)()],f.prototype,"rimLightingMix",null),n([(0,t.serialize)()],f.prototype,"rimFresnelPower",null),n([(0,t.serialize)()],f.prototype,"rimLift",null),n([(0,t.serialize)()],f.prototype,"outlineWidth",null),n([(0,t.serialize)()],f.prototype,"outlineScaledMaxDistance",null),n([(0,t.serialize)()],f.prototype,"outlineLightingMix",null),n([(0,t.serialize)()],f.prototype,"uvAnimationScrollX",null),n([(0,t.serialize)()],f.prototype,"uvAnimationScrollY",null),n([(0,t.serialize)()],f.prototype,"uvAnimationRotation",null),n([(0,t.serialize)("alphaTest")],f.prototype,"_alphaTest",void 0),n([(0,t.serialize)()],f.prototype,"alphaTest",null),n([(0,t.serialize)()],f.prototype,"alphaBlend",null),n([(0,t.serialize)("debugMode")],f.prototype,"_debugMode",void 0),n([(0,t.expandToProperty)("_markAllSubMeshesAsMiscDirty")],f.prototype,"debugMode",void 0),n([(0,t.expandToProperty)("_markAllSubMeshesAsMiscDirty")],f.prototype,"outlineColorMode",void 0),n([(0,t.serialize)()],f.prototype,"cullMode",null),n([(0,t.serialize)()],f.prototype,"_outlineCullMode",void 0),n([(0,t.expandToProperty)("_markAllSubMeshesAsMiscDirty")],f.prototype,"outlineCullMode",void 0),n([(0,t.serialize)()],f.prototype,"useLogarithmicDepth",null),window.MToonMaterial=i.MToonMaterial})();